//  To parse this JSON data, first install
//
//      json.hpp  https://github.com/nlohmann/json
//
//  Then include this file, and then do
//
//     quicktype::Animations data = nlohmann::json::parse(jsonString);
// generated by https://app.quicktype.io/ with all options are OFF and Others/Use Permissive is ON

#pragma once

#include "nlohmann/json.hpp"

#include <optional>
#include <stdexcept>
#include <regex>

#ifndef NLOHMANN_OPT_HELPER
#define NLOHMANN_OPT_HELPER
namespace nlohmann {
	template <typename T>
	struct adl_serializer<std::shared_ptr<T>> {
		static void to_json(json & j, const std::shared_ptr<T> & opt) {
			if (!opt) j = nullptr; else j = *opt;
		}

		static std::shared_ptr<T> from_json(const json & j) {
			if (j.is_null()) return std::unique_ptr<T>(); else return std::unique_ptr<T>(new T(j.get<T>()));
		}
	};
}
#endif

namespace quicktype {
	using nlohmann::json;

	inline json get_untyped(const json & j, const char * property) {
		if (j.find(property) != j.end()) {
			return j.at(property).get<json>();
		}
		return json();
	}

	inline json get_untyped(const json & j, std::string property) {
		return get_untyped(j, property.data());
	}

	template <typename T>
	inline std::shared_ptr<T> get_optional(const json & j, const char * property) {
		if (j.find(property) != j.end()) {
			return j.at(property).get<std::shared_ptr<T>>();
		}
		return std::shared_ptr<T>();
	}

	template <typename T>
	inline std::shared_ptr<T> get_optional(const json & j, std::string property) {
		return get_optional<T>(j, property.data());
	}

	class Bookmark {
	public:
		Bookmark() = default;
		virtual ~Bookmark() = default;

	private:
		std::string name;
		std::string time;

	public:
		const std::string & get_name() const { return name; }
		std::string & get_mutable_name() { return name; }
		void set_name(const std::string & value) { this->name = value; }

		const std::string & get_time() const { return time; }
		std::string & get_mutable_time() { return time; }
		void set_time(const std::string & value) { this->time = value; }
	};

	enum class Descr : int { EMPTY_PALLET, IDLE_CONVEYOR, MOVING_FORWARD, PART_LOADED };

	enum class EventType : int { ANIMATION, ANIMATION_ADDITIVE, HIDE, SHOW, STATE };

	class Event {
	public:
		Event() = default;
		virtual ~Event() = default;

	private:
		quicktype::EventType type;
		std::shared_ptr<std::string> placement_rel_to;
		std::shared_ptr<quicktype::Descr> descr;
		std::shared_ptr<std::string> data;

	public:
		const quicktype::EventType & get_type() const { return type; }
		quicktype::EventType & get_mutable_type() { return type; }
		void set_type(const quicktype::EventType & value) { this->type = value; }

		std::shared_ptr<std::string> get_placement_rel_to() const { return placement_rel_to; }
		void set_placement_rel_to(std::shared_ptr<std::string> value) { this->placement_rel_to = value; }

		std::shared_ptr<quicktype::Descr> get_descr() const { return descr; }
		void set_descr(std::shared_ptr<quicktype::Descr> value) { this->descr = value; }

		std::shared_ptr<std::string> get_data() const { return data; }
		void set_data(std::shared_ptr<std::string> value) { this->data = value; }
	};

	enum class TriggerType : int { TIMESTAMP };

	class Trigger {
	public:
		Trigger() = default;
		virtual ~Trigger() = default;

	private:
		quicktype::TriggerType type;
		std::string data;

	public:
		const quicktype::TriggerType & get_type() const { return type; }
		quicktype::TriggerType & get_mutable_type() { return type; }
		void set_type(const quicktype::TriggerType & value) { this->type = value; }

		const std::string & get_data() const { return data; }
		std::string & get_mutable_data() { return data; }
		void set_data(const std::string & value) { this->data = value; }
	};

	class Action {
	public:
		Action() = default;
		virtual ~Action() = default;

	private:
		quicktype::Trigger trigger;
		quicktype::Event event;

	public:
		const quicktype::Trigger & get_trigger() const { return trigger; }
		quicktype::Trigger & get_mutable_trigger() { return trigger; }
		void set_trigger(const quicktype::Trigger & value) { this->trigger = value; }

		const quicktype::Event & get_event() const { return event; }
		quicktype::Event & get_mutable_event() { return event; }
		void set_event(const quicktype::Event & value) { this->event = value; }
	};

	class Node {
	public:
		Node() = default;
		virtual ~Node() = default;

	private:
		std::string name;
		std::vector<quicktype::Action> actions;

	public:
		const std::string & get_name() const { return name; }
		std::string & get_mutable_name() { return name; }
		void set_name(const std::string & value) { this->name = value; }

		const std::vector<quicktype::Action> & get_actions() const { return actions; }
		std::vector<quicktype::Action> & get_mutable_actions() { return actions; }
		void set_actions(const std::vector<quicktype::Action> & value) { this->actions = value; }
	};

	class Animations {
	public:
		Animations() = default;
		virtual ~Animations() = default;

	private:
		std::vector<quicktype::Node> nodes;
		std::vector<quicktype::Bookmark> bookmarks;

	public:
		const std::vector<quicktype::Node> & get_nodes() const { return nodes; }
		std::vector<quicktype::Node> & get_mutable_nodes() { return nodes; }
		void set_nodes(const std::vector<quicktype::Node> & value) { this->nodes = value; }

		const std::vector<quicktype::Bookmark> & get_bookmarks() const { return bookmarks; }
		std::vector<quicktype::Bookmark> & get_mutable_bookmarks() { return bookmarks; }
		void set_bookmarks(const std::vector<quicktype::Bookmark> & value) { this->bookmarks = value; }
	};
}

namespace nlohmann {
	namespace detail {
		void from_json(const json & j, quicktype::Bookmark & x);
		void to_json(json & j, const quicktype::Bookmark & x);

		void from_json(const json & j, quicktype::Event & x);
		void to_json(json & j, const quicktype::Event & x);

		void from_json(const json & j, quicktype::Trigger & x);
		void to_json(json & j, const quicktype::Trigger & x);

		void from_json(const json & j, quicktype::Action & x);
		void to_json(json & j, const quicktype::Action & x);

		void from_json(const json & j, quicktype::Node & x);
		void to_json(json & j, const quicktype::Node & x);

		void from_json(const json & j, quicktype::Animations & x);
		void to_json(json & j, const quicktype::Animations & x);

		void from_json(const json & j, quicktype::Descr & x);
		void to_json(json & j, const quicktype::Descr & x);

		void from_json(const json & j, quicktype::EventType & x);
		void to_json(json & j, const quicktype::EventType & x);

		void from_json(const json & j, quicktype::TriggerType & x);
		void to_json(json & j, const quicktype::TriggerType & x);

		inline void from_json(const json & j, quicktype::Bookmark& x) {
			x.set_name(j.at("name").get<std::string>());
			x.set_time(j.at("time").get<std::string>());
		}

		inline void to_json(json & j, const quicktype::Bookmark & x) {
			j = json::object();
			j["name"] = x.get_name();
			j["time"] = x.get_time();
		}

		inline void from_json(const json & j, quicktype::Event& x) {
			x.set_type(j.at("type").get<quicktype::EventType>());
			x.set_placement_rel_to(quicktype::get_optional<std::string>(j, "placementRelTo"));
			x.set_descr(quicktype::get_optional<quicktype::Descr>(j, "descr"));
			x.set_data(quicktype::get_optional<std::string>(j, "data"));
		}

		inline void to_json(json & j, const quicktype::Event & x) {
			j = json::object();
			j["type"] = x.get_type();
			j["placementRelTo"] = x.get_placement_rel_to();
			j["descr"] = x.get_descr();
			j["data"] = x.get_data();
		}

		inline void from_json(const json & j, quicktype::Trigger& x) {
			x.set_type(j.at("type").get<quicktype::TriggerType>());
			x.set_data(j.at("data").get<std::string>());
		}

		inline void to_json(json & j, const quicktype::Trigger & x) {
			j = json::object();
			j["type"] = x.get_type();
			j["data"] = x.get_data();
		}

		inline void from_json(const json & j, quicktype::Action& x) {
			x.set_trigger(j.at("trigger").get<quicktype::Trigger>());
			x.set_event(j.at("event").get<quicktype::Event>());
		}

		inline void to_json(json & j, const quicktype::Action & x) {
			j = json::object();
			j["trigger"] = x.get_trigger();
			j["event"] = x.get_event();
		}

		inline void from_json(const json & j, quicktype::Node& x) {
			x.set_name(j.at("name").get<std::string>());
			x.set_actions(j.at("actions").get<std::vector<quicktype::Action>>());
		}

		inline void to_json(json & j, const quicktype::Node & x) {
			j = json::object();
			j["name"] = x.get_name();
			j["actions"] = x.get_actions();
		}

		inline void from_json(const json & j, quicktype::Animations& x) {
			x.set_nodes(j.at("nodes").get<std::vector<quicktype::Node>>());
			x.set_bookmarks(j.at("bookmarks").get<std::vector<quicktype::Bookmark>>());
		}

		inline void to_json(json & j, const quicktype::Animations & x) {
			j = json::object();
			j["nodes"] = x.get_nodes();
			j["bookmarks"] = x.get_bookmarks();
		}

		inline void from_json(const json & j, quicktype::Descr & x) {
			if (j == "empty pallet") x = quicktype::Descr::EMPTY_PALLET;
			else if (j == "idle conveyor") x = quicktype::Descr::IDLE_CONVEYOR;
			else if (j == "moving forward") x = quicktype::Descr::MOVING_FORWARD;
			else if (j == "part loaded") x = quicktype::Descr::PART_LOADED;
			else throw "Input JSON does not conform to schema";
		}

		inline void to_json(json & j, const quicktype::Descr & x) {
			switch (x) {
			case quicktype::Descr::EMPTY_PALLET: j = "empty pallet"; break;
			case quicktype::Descr::IDLE_CONVEYOR: j = "idle conveyor"; break;
			case quicktype::Descr::MOVING_FORWARD: j = "moving forward"; break;
			case quicktype::Descr::PART_LOADED: j = "part loaded"; break;
			default: throw "This should not happen";
			}
		}

		inline void from_json(const json & j, quicktype::EventType & x) {
			if (j == "animation") x = quicktype::EventType::ANIMATION;
			else if (j == "animationAdditive") x = quicktype::EventType::ANIMATION_ADDITIVE;
			else if (j == "hide") x = quicktype::EventType::HIDE;
			else if (j == "show") x = quicktype::EventType::SHOW;
			else if (j == "state") x = quicktype::EventType::STATE;
			else throw "Input JSON does not conform to schema";
		}

		inline void to_json(json & j, const quicktype::EventType & x) {
			switch (x) {
			case quicktype::EventType::ANIMATION: j = "animation"; break;
			case quicktype::EventType::ANIMATION_ADDITIVE: j = "animationAdditive"; break;
			case quicktype::EventType::HIDE: j = "hide"; break;
			case quicktype::EventType::SHOW: j = "show"; break;
			case quicktype::EventType::STATE: j = "state"; break;
			default: throw "This should not happen";
			}
		}

		inline void from_json(const json & j, quicktype::TriggerType & x) {
			if (j == "timestamp") x = quicktype::TriggerType::TIMESTAMP;
			else throw "Input JSON does not conform to schema";
		}

		inline void to_json(json & j, const quicktype::TriggerType & x) {
			switch (x) {
			case quicktype::TriggerType::TIMESTAMP: j = "timestamp"; break;
			default: throw "This should not happen";
			}
		}
	}
}

