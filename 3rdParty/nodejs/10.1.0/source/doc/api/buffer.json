{
  "source": "doc/api/buffer.md",
  "modules": [
    {
      "textRaw": "Buffer",
      "name": "buffer",
      "introduced_in": "v0.1.90",
      "stability": 2,
      "stabilityText": "Stable",
      "desc": "<p>Prior to the introduction of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>, the JavaScript language had no\nmechanism for reading or manipulating streams of binary data. The <code>Buffer</code> class\nwas introduced as part of the Node.js API to enable interaction with octet\nstreams in TCP streams, file system operations, and other contexts.</p>\n<p>With <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> now available, the <code>Buffer</code> class implements the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a> API in a manner that is more optimized and suitable for Node.js.</p>\n<p>Instances of the <code>Buffer</code> class are similar to arrays of integers but\ncorrespond to fixed-sized, raw memory allocations outside the V8 heap.\nThe size of the <code>Buffer</code> is established when it is created and cannot be\nchanged.</p>\n<p>The <code>Buffer</code> class is within the global scope, making it unlikely that one\nwould need to ever use <code>require(&#39;buffer&#39;).Buffer</code>.</p>\n<pre><code class=\"lang-js\">// Creates a zero-filled Buffer of length 10.\nconst buf1 = Buffer.alloc(10);\n\n// Creates a Buffer of length 10, filled with 0x1.\nconst buf2 = Buffer.alloc(10, 1);\n\n// Creates an uninitialized buffer of length 10.\n// This is faster than calling Buffer.alloc() but the returned\n// Buffer instance might contain old data that needs to be\n// overwritten using either fill() or write().\nconst buf3 = Buffer.allocUnsafe(10);\n\n// Creates a Buffer containing [0x1, 0x2, 0x3].\nconst buf4 = Buffer.from([1, 2, 3]);\n\n// Creates a Buffer containing UTF-8 bytes [0x74, 0xc3, 0xa9, 0x73, 0x74].\nconst buf5 = Buffer.from(&#39;tést&#39;);\n\n// Creates a Buffer containing Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].\nconst buf6 = Buffer.from(&#39;tést&#39;, &#39;latin1&#39;);\n</code></pre>\n",
      "modules": [
        {
          "textRaw": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`",
          "name": "`buffer.from()`,_`buffer.alloc()`,_and_`buffer.allocunsafe()`",
          "desc": "<p>In versions of Node.js prior to 6.0.0, <code>Buffer</code> instances were created using the\n<code>Buffer</code> constructor function, which allocates the returned <code>Buffer</code>\ndifferently based on what arguments are provided:</p>\n<ul>\n<li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>)\nallocates a new <code>Buffer</code> object of the specified size. Prior to Node.js 8.0.0,\nthe memory allocated for such <code>Buffer</code> instances is <em>not</em> initialized and\n<em>can contain sensitive data</em>. Such <code>Buffer</code> instances <em>must</em> be subsequently\ninitialized by using either <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> or by writing to the\nentire <code>Buffer</code>. While this behavior is <em>intentional</em> to improve performance,\ndevelopment experience has demonstrated that a more explicit distinction is\nrequired between creating a fast-but-uninitialized <code>Buffer</code> versus creating a\nslower-but-safer <code>Buffer</code>. Starting in Node.js 8.0.0, <code>Buffer(num)</code> and\n<code>new Buffer(num)</code> will return a <code>Buffer</code> with initialized memory.</li>\n<li>Passing a string, array, or <code>Buffer</code> as the first argument copies the\npassed object&#39;s data into the <code>Buffer</code>.</li>\n<li>Passing an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> or a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a> returns a <code>Buffer</code> that\nshares allocated memory with the given array buffer.</li>\n</ul>\n<p>Because the behavior of <code>new Buffer()</code> is different depending on the type of the\nfirst argument, security and reliability issues can be inadvertently introduced\ninto applications when argument validation or <code>Buffer</code> initialization is not\nperformed.</p>\n<p>To make the creation of <code>Buffer</code> instances more reliable and less error-prone,\nthe various forms of the <code>new Buffer()</code> constructor have been <strong>deprecated</strong>\nand replaced by separate <code>Buffer.from()</code>, <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a>, and\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> methods.</p>\n<p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors\nto one of these new APIs.</em></p>\n<ul>\n<li><a href=\"#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a> returns a new <code>Buffer</code> that <em>contains a copy</em> of the\nprovided octets.</li>\n<li><a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a>\nreturns a new <code>Buffer</code> that <em>shares the same allocated memory</em> as the given\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>.</li>\n<li><a href=\"#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a> returns a new <code>Buffer</code> that <em>contains a copy</em> of the\ncontents of the given <code>Buffer</code>.</li>\n<li><a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a> returns a new\n<code>Buffer</code> that <em>contains a copy</em> of the provided string.</li>\n<li><a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> returns a new\ninitialized <code>Buffer</code> of the specified size. This method is slower than\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe(size)</code></a> but guarantees that newly\ncreated <code>Buffer</code> instances never contain old data that is potentially\nsensitive.</li>\n<li><a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe(size)</code></a> and\n<a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow(size)</code></a> each return a\nnew uninitialized <code>Buffer</code> of the specified <code>size</code>. Because the <code>Buffer</code> is\nuninitialized, the allocated segment of memory might contain old data that is\npotentially sensitive.</li>\n</ul>\n<p><code>Buffer</code> instances returned by <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> <em>may</em> be allocated off\na shared internal memory pool if <code>size</code> is less than or equal to half\n<a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a>. Instances returned by <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a> <em>never</em>\nuse the shared internal memory pool.</p>\n",
          "modules": [
            {
              "textRaw": "The `--zero-fill-buffers` command line option",
              "name": "the_`--zero-fill-buffers`_command_line_option",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "desc": "<p>Node.js can be started using the <code>--zero-fill-buffers</code> command line option to\ncause all newly allocated <code>Buffer</code> instances to be zero-filled upon creation by\ndefault, including buffers returned by <code>new Buffer(size)</code>,\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>, <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a>, and <code>new\nSlowBuffer(size)</code>. Use of this flag can have a significant negative impact on\nperformance. Use of the <code>--zero-fill-buffers</code> option is recommended only when\nnecessary to enforce that newly allocated <code>Buffer</code> instances cannot contain old\ndata that is potentially sensitive.</p>\n<pre><code class=\"lang-txt\">$ node --zero-fill-buffers\n&gt; Buffer.allocUnsafe(5);\n&lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n",
              "type": "module",
              "displayName": "The `--zero-fill-buffers` command line option"
            },
            {
              "textRaw": "What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?",
              "name": "what_makes_`buffer.allocunsafe()`_and_`buffer.allocunsafeslow()`_\"unsafe\"?",
              "desc": "<p>When calling <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> and <a href=\"#buffer_class_method_buffer_allocunsafeslow_size\"><code>Buffer.allocUnsafeSlow()</code></a>, the\nsegment of allocated memory is <em>uninitialized</em> (it is not zeroed-out). While\nthis design makes the allocation of memory quite fast, the allocated segment of\nmemory might contain old data that is potentially sensitive. Using a <code>Buffer</code>\ncreated by <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> without <em>completely</em> overwriting the memory\ncan allow this old data to be leaked when the <code>Buffer</code> memory is read.</p>\n<p>While there are clear performance advantages to using <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>,\nextra care <em>must</em> be taken in order to avoid introducing security\nvulnerabilities into an application.</p>\n",
              "type": "module",
              "displayName": "What makes `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` \"unsafe\"?"
            }
          ],
          "type": "module",
          "displayName": "`Buffer.from()`, `Buffer.alloc()`, and `Buffer.allocUnsafe()`"
        },
        {
          "textRaw": "Buffers and Character Encodings",
          "name": "buffers_and_character_encodings",
          "meta": {
            "changes": [
              {
                "version": "v6.4.0",
                "pr-url": "https://github.com/nodejs/node/pull/7111",
                "description": "Introduced `latin1` as an alias for `binary`."
              },
              {
                "version": "v5.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/2859",
                "description": "Removed the deprecated `raw` and `raws` encodings."
              }
            ]
          },
          "desc": "<p>When string data is stored in or extracted out of a <code>Buffer</code> instance, a\ncharacter encoding may be specified.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;hello world&#39;, &#39;ascii&#39;);\n\nconsole.log(buf.toString(&#39;hex&#39;));\n// Prints: 68656c6c6f20776f726c64\nconsole.log(buf.toString(&#39;base64&#39;));\n// Prints: aGVsbG8gd29ybGQ=\n\nconsole.log(Buffer.from(&#39;fhqwhgads&#39;, &#39;ascii&#39;));\n// Prints: &lt;Buffer 66 68 71 77 68 67 61 64 73&gt;\nconsole.log(Buffer.from(&#39;fhqwhgads&#39;, &#39;utf16le&#39;));\n// Prints: &lt;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00&gt;\n</code></pre>\n<p>The character encodings currently supported by Node.js include:</p>\n<ul>\n<li><p><code>&#39;ascii&#39;</code> - For 7-bit ASCII data only. This encoding is fast and will strip\nthe high bit if set.</p>\n</li>\n<li><p><code>&#39;utf8&#39;</code> - Multibyte encoded Unicode characters. Many web pages and other\ndocument formats use UTF-8.</p>\n</li>\n<li><p><code>&#39;utf16le&#39;</code> - 2 or 4 bytes, little-endian encoded Unicode characters.\nSurrogate pairs (U+10000 to U+10FFFF) are supported.</p>\n</li>\n<li><p><code>&#39;ucs2&#39;</code> - Alias of <code>&#39;utf16le&#39;</code>.</p>\n</li>\n<li><p><code>&#39;base64&#39;</code> - Base64 encoding. When creating a <code>Buffer</code> from a string,\nthis encoding will also correctly accept &quot;URL and Filename Safe Alphabet&quot; as\nspecified in <a href=\"https://tools.ietf.org/html/rfc4648#section-5\">RFC4648, Section 5</a>.</p>\n</li>\n<li><p><code>&#39;latin1&#39;</code> - A way of encoding the <code>Buffer</code> into a one-byte encoded string\n(as defined by the IANA in <a href=\"https://tools.ietf.org/html/rfc1345\">RFC1345</a>,\npage 63, to be the Latin-1 supplement block and C0/C1 control codes).</p>\n</li>\n<li><p><code>&#39;binary&#39;</code> - Alias for <code>&#39;latin1&#39;</code>.</p>\n</li>\n<li><p><code>&#39;hex&#39;</code> - Encode each byte as two hexadecimal characters.</p>\n</li>\n</ul>\n<p>Modern Web browsers follow the <a href=\"https://encoding.spec.whatwg.org/\">WHATWG Encoding Standard</a> which aliases\nboth <code>&#39;latin1&#39;</code> and <code>&#39;ISO-8859-1&#39;</code> to <code>&#39;win-1252&#39;</code>. This means that while doing\nsomething like <code>http.get()</code>, if the returned charset is one of those listed in\nthe WHATWG specification it is possible that the server actually returned\n<code>&#39;win-1252&#39;</code>-encoded data, and using <code>&#39;latin1&#39;</code> encoding may incorrectly decode\nthe characters.</p>\n",
          "type": "module",
          "displayName": "Buffers and Character Encodings"
        },
        {
          "textRaw": "Buffers and TypedArray",
          "name": "buffers_and_typedarray",
          "meta": {
            "changes": [
              {
                "version": "v3.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/2002",
                "description": "The `Buffer`s class now inherits from `Uint8Array`."
              }
            ]
          },
          "desc": "<p><code>Buffer</code> instances are also <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a> instances. However, there are subtle\nincompatibilities with <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>. For example, while\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice\"><code>ArrayBuffer#slice()</code></a> creates a copy of the slice, the implementation of\n<a href=\"#buffer_buf_slice_start_end\"><code>Buffer#slice()</code></a> creates a view over the existing <code>Buffer</code>\nwithout copying, making <a href=\"#buffer_buf_slice_start_end\"><code>Buffer#slice()</code></a> far more efficient.</p>\n<p>It is also possible to create new <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instances from a <code>Buffer</code> with\nthe following caveats:</p>\n<ol>\n<li><p>The <code>Buffer</code> object&#39;s memory is copied to the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>, not shared.</p>\n</li>\n<li><p>The <code>Buffer</code> object&#39;s memory is interpreted as an array of distinct\nelements, and not as a byte array of the target type. That is,\n<code>new Uint32Array(Buffer.from([1, 2, 3, 4]))</code> creates a 4-element <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array\"><code>Uint32Array</code></a>\nwith elements <code>[1, 2, 3, 4]</code>, not a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array\"><code>Uint32Array</code></a> with a single element\n<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>\n</li>\n</ol>\n<p>It is possible to create a new <code>Buffer</code> that shares the same allocated memory as\na <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance by using the <code>TypeArray</code> object&#39;s <code>.buffer</code> property.</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Copies the contents of `arr`\nconst buf1 = Buffer.from(arr);\n// Shares memory with `arr`\nconst buf2 = Buffer.from(arr.buffer);\n\nconsole.log(buf1);\n// Prints: &lt;Buffer 88 a0&gt;\nconsole.log(buf2);\n// Prints: &lt;Buffer 88 13 a0 0f&gt;\n\narr[1] = 6000;\n\nconsole.log(buf1);\n// Prints: &lt;Buffer 88 a0&gt;\nconsole.log(buf2);\n// Prints: &lt;Buffer 88 13 70 17&gt;\n</code></pre>\n<p>Note that when creating a <code>Buffer</code> using a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>&#39;s <code>.buffer</code>, it is\npossible to use only a portion of the underlying <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> by passing in\n<code>byteOffset</code> and <code>length</code> parameters.</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(20);\nconst buf = Buffer.from(arr.buffer, 0, 16);\n\nconsole.log(buf.length);\n// Prints: 16\n</code></pre>\n<p>The <code>Buffer.from()</code> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from\"><code>TypedArray.from()</code></a> have different signatures and\nimplementations. Specifically, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> variants accept a second\nargument that is a mapping function that is invoked on every element of the\ntyped array:</p>\n<ul>\n<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>\n</ul>\n<p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping\nfunction:</p>\n<ul>\n<li><a href=\"#buffer_class_method_buffer_from_array\"><code>Buffer.from(array)</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_buffer\"><code>Buffer.from(buffer)</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a></li>\n<li><a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a></li>\n</ul>\n",
          "type": "module",
          "displayName": "Buffers and TypedArray"
        },
        {
          "textRaw": "Buffers and iteration",
          "name": "buffers_and_iteration",
          "desc": "<p><code>Buffer</code> instances can be iterated over using <code>for..of</code> syntax:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3]);\n\n// Prints:\n//   1\n//   2\n//   3\nfor (const b of buf) {\n  console.log(b);\n}\n</code></pre>\n<p>Additionally, the <a href=\"#buffer_buf_values\"><code>buf.values()</code></a>, <a href=\"#buffer_buf_keys\"><code>buf.keys()</code></a>, and\n<a href=\"#buffer_buf_entries\"><code>buf.entries()</code></a> methods can be used to create iterators.</p>\n",
          "type": "module",
          "displayName": "Buffers and iteration"
        },
        {
          "textRaw": "Buffer Constants",
          "name": "buffer_constants",
          "meta": {
            "added": [
              "v8.2.0"
            ],
            "changes": []
          },
          "desc": "<p>Note that <code>buffer.constants</code> is a property on the <code>buffer</code> module returned by\n<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>\n",
          "properties": [
            {
              "textRaw": "`MAX_LENGTH` {integer} The largest size allowed for a single `Buffer` instance. ",
              "type": "integer",
              "name": "MAX_LENGTH",
              "meta": {
                "added": [
                  "v8.2.0"
                ],
                "changes": []
              },
              "desc": "<p>On 32-bit architectures, this value is <code>(2^30)-1</code> (~1GB).\nOn 64-bit architectures, this value is <code>(2^31)-1</code> (~2GB).</p>\n<p>This value is also available as <a href=\"#buffer_buffer_kmaxlength\"><code>buffer.kMaxLength</code></a>.</p>\n",
              "shortDesc": "The largest size allowed for a single `Buffer` instance."
            },
            {
              "textRaw": "`MAX_STRING_LENGTH` {integer} The largest length allowed for a single `string` instance. ",
              "type": "integer",
              "name": "MAX_STRING_LENGTH",
              "meta": {
                "added": [
                  "v8.2.0"
                ],
                "changes": []
              },
              "desc": "<p>Represents the largest <code>length</code> that a <code>string</code> primitive can have, counted\nin UTF-16 code units.</p>\n<p>This value may depend on the JS engine that is being used.</p>\n",
              "shortDesc": "The largest length allowed for a single `string` instance."
            }
          ],
          "type": "module",
          "displayName": "Buffer Constants"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Buffer",
          "type": "class",
          "name": "Buffer",
          "desc": "<p>The <code>Buffer</code> class is a global type for dealing with binary data directly.\nIt can be constructed in a variety of ways.</p>\n",
          "classMethods": [
            {
              "textRaw": "Class Method: Buffer.alloc(size[, fill[, encoding]])",
              "type": "classMethod",
              "name": "alloc",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18129",
                    "description": "Attempting to fill a non-zero length buffer with a zero length buffer triggers a thrown exception."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/17427",
                    "description": "Specifying an invalid string for `fill` triggers a thrown exception."
                  },
                  {
                    "version": "v8.9.3",
                    "pr-url": "https://github.com/nodejs/node/pull/17428",
                    "description": "Specifying an invalid string for `fill` now results in a zero-filled buffer."
                  }
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer} The desired length of the new `Buffer`. ",
                      "name": "size",
                      "type": "integer",
                      "desc": "The desired length of the new `Buffer`."
                    },
                    {
                      "textRaw": "`fill` {string|Buffer|integer} A value to pre-fill the new `Buffer` with. **Default:** `0`. ",
                      "name": "fill",
                      "type": "string|Buffer|integer",
                      "default": "`0`",
                      "desc": "A value to pre-fill the new `Buffer` with.",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} If `fill` is a string, this is its encoding. **Default:** `'utf8'`. ",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `fill` is a string, this is its encoding.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    },
                    {
                      "name": "fill",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the\n<code>Buffer</code> will be <em>zero-filled</em>.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(5);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling\n<a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(fill)</code></a>.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(5, &#39;a&#39;);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 61 61 61 61 61&gt;\n</code></pre>\n<p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be\ninitialized by calling <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(fill, encoding)</code></a>.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(11, &#39;aGVsbG8gd29ybGQ=&#39;, &#39;base64&#39;);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;\n</code></pre>\n<p>Calling <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> can be significantly slower than the alternative\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> but ensures that the newly created <code>Buffer</code> instance\ncontents will <em>never contain sensitive data</em>.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.allocUnsafe(size)",
              "type": "classMethod",
              "name": "allocUnsafe",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": [
                  {
                    "version": "v7.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/7079",
                    "description": "Passing a negative `size` will now throw an error."
                  }
                ]
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer} The desired length of the new `Buffer`. ",
                      "name": "size",
                      "type": "integer",
                      "desc": "The desired length of the new `Buffer`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> instead to initialize\n<code>Buffer</code> instances with zeroes.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(10);\n\nconsole.log(buf);\n// Prints: (contents may vary): &lt;Buffer a0 8b 28 3f 01 00 00 00 50 32&gt;\n\nbuf.fill(0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n<p>Note that the <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of\nsize <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a> that is used as a pool for the fast allocation of new\n<code>Buffer</code> instances created using <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> and the deprecated\n<code>new Buffer(size)</code> constructor only when <code>size</code> is less than or equal to\n<code>Buffer.poolSize &gt;&gt; 1</code> (floor of <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a> divided by two).</p>\n<p>Use of this pre-allocated internal memory pool is a key difference between\ncalling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>.\nSpecifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal <code>Buffer</code>\npool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal\n<code>Buffer</code> pool if <code>size</code> is less than or equal to half <a href=\"#buffer_class_property_buffer_poolsize\"><code>Buffer.poolSize</code></a>. The\ndifference is subtle but can be important when an application requires the\nadditional performance that <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> provides.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.allocUnsafeSlow(size)",
              "type": "classMethod",
              "name": "allocUnsafeSlow",
              "meta": {
                "added": [
                  "v5.12.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {integer} The desired length of the new `Buffer`. ",
                      "name": "size",
                      "type": "integer",
                      "desc": "The desired length of the new `Buffer`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not\ninitialized</em>. The contents of the newly created <code>Buffer</code> are unknown and\n<em>may contain sensitive data</em>. Use <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> to initialize\nsuch <code>Buffer</code> instances with zeroes.</p>\n<p>When using <a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a> to allocate new <code>Buffer</code> instances,\nallocations under 4KB are sliced from a single pre-allocated <code>Buffer</code>. This\nallows applications to avoid the garbage collection overhead of creating many\nindividually allocated <code>Buffer</code> instances. This approach improves both\nperformance and memory usage by eliminating the need to track and clean up as\nmany persistent objects.</p>\n<p>However, in the case where a developer may need to retain a small chunk of\nmemory from a pool for an indeterminate amount of time, it may be appropriate\nto create an un-pooled <code>Buffer</code> instance using <code>Buffer.allocUnsafeSlow()</code> and\nthen copying out the relevant bits.</p>\n<pre><code class=\"lang-js\">// Need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on(&#39;readable&#39;, () =&gt; {\n  const data = socket.read();\n\n  // Allocate for retained data\n  const sb = Buffer.allocUnsafeSlow(10);\n\n  // Copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n\n  store.push(sb);\n});\n</code></pre>\n<p><code>Buffer.allocUnsafeSlow()</code> should be used only as a last resort after a\ndeveloper has observed undue memory retention in their applications.</p>\n<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.byteLength(string[, encoding])",
              "type": "classMethod",
              "name": "byteLength",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": [
                  {
                    "version": "v7.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/8946",
                    "description": "Passing invalid input will now throw an error."
                  },
                  {
                    "version": "v5.10.0",
                    "pr-url": "https://github.com/nodejs/node/pull/5255",
                    "description": "The `string` parameter can now be any `TypedArray`, `DataView` or `ArrayBuffer`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The number of bytes contained within `string`. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "The number of bytes contained within `string`."
                  },
                  "params": [
                    {
                      "textRaw": "`string` {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} A value to calculate the length of. ",
                      "name": "string",
                      "type": "string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer",
                      "desc": "A value to calculate the length of."
                    },
                    {
                      "textRaw": "`encoding` {string} If `string` is a string, this is its encoding. **Default:** `'utf8'`. ",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `string` is a string, this is its encoding.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns the actual byte length of a string. This is not the same as\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length\"><code>String.prototype.length</code></a> since that returns the number of <em>characters</em> in\na string.</p>\n<p>For <code>&#39;base64&#39;</code> and <code>&#39;hex&#39;</code>, this function assumes valid input. For strings that\ncontain non-Base64/Hex-encoded data (e.g. whitespace), the return value might be\ngreater than the length of a <code>Buffer</code> created from the string.</p>\n<pre><code class=\"lang-js\">const str = &#39;\\u00bd + \\u00bc = \\u00be&#39;;\n\nconsole.log(`${str}: ${str.length} characters, ` +\n            `${Buffer.byteLength(str, &#39;utf8&#39;)} bytes`);\n// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes\n</code></pre>\n<p>When <code>string</code> is a <code>Buffer</code>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\"><code>DataView</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a>/\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a>, the actual byte length is returned.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.compare(buf1, buf2)",
              "type": "classMethod",
              "name": "compare",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The arguments can now be `Uint8Array`s."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`buf1` {Buffer|Uint8Array} ",
                      "name": "buf1",
                      "type": "Buffer|Uint8Array"
                    },
                    {
                      "textRaw": "`buf2` {Buffer|Uint8Array} ",
                      "name": "buf2",
                      "type": "Buffer|Uint8Array"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buf1"
                    },
                    {
                      "name": "buf2"
                    }
                  ]
                }
              ],
              "desc": "<p>Compares <code>buf1</code> to <code>buf2</code> typically for the purpose of sorting arrays of\n<code>Buffer</code> instances. This is equivalent to calling\n<a href=\"#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend\"><code>buf1.compare(buf2)</code></a>.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;1234&#39;);\nconst buf2 = Buffer.from(&#39;0123&#39;);\nconst arr = [buf1, buf2];\n\nconsole.log(arr.sort(Buffer.compare));\n// Prints: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]\n// (This result is equal to: [buf2, buf1])\n</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.concat(list[, totalLength])",
              "type": "classMethod",
              "name": "concat",
              "meta": {
                "added": [
                  "v0.7.11"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The elements of `list` can now be `Uint8Array`s."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} ",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`list` {Buffer[] | Uint8Array[]} List of `Buffer` or [`Uint8Array`] instances to concat. ",
                      "name": "list",
                      "type": "Buffer[] | Uint8Array[]",
                      "desc": "List of `Buffer` or [`Uint8Array`] instances to concat."
                    },
                    {
                      "textRaw": "`totalLength` {integer} Total length of the `Buffer` instances in `list` when concatenated. ",
                      "name": "totalLength",
                      "type": "integer",
                      "desc": "Total length of the `Buffer` instances in `list` when concatenated.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "list"
                    },
                    {
                      "name": "totalLength",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new <code>Buffer</code> which is the result of concatenating all the <code>Buffer</code>\ninstances in the <code>list</code> together.</p>\n<p>If the list has no items, or if the <code>totalLength</code> is 0, then a new zero-length\n<code>Buffer</code> is returned.</p>\n<p>If <code>totalLength</code> is not provided, it is calculated from the <code>Buffer</code> instances\nin <code>list</code>. This however causes an additional loop to be executed in order to\ncalculate the <code>totalLength</code>, so it is faster to provide the length explicitly if\nit is already known.</p>\n<p>If <code>totalLength</code> is provided, it is coerced to an unsigned integer. If the\ncombined length of the <code>Buffer</code>s in <code>list</code> exceeds <code>totalLength</code>, the result is\ntruncated to <code>totalLength</code>.</p>\n<pre><code class=\"lang-js\">// Create a single `Buffer` from a list of three `Buffer` instances.\n\nconst buf1 = Buffer.alloc(10);\nconst buf2 = Buffer.alloc(14);\nconst buf3 = Buffer.alloc(18);\nconst totalLength = buf1.length + buf2.length + buf3.length;\n\nconsole.log(totalLength);\n// Prints: 42\n\nconst bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\n\nconsole.log(bufA);\n// Prints: &lt;Buffer 00 00 00 00 ...&gt;\nconsole.log(bufA.length);\n// Prints: 42\n</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(array)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`array` {integer[]} ",
                      "name": "array",
                      "type": "integer[]"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "array"
                    }
                  ]
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<pre><code class=\"lang-js\">// Creates a new Buffer containing UTF-8 bytes of the string &#39;buffer&#39;\nconst buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code>.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`arrayBuffer` {ArrayBuffer|SharedArrayBuffer} An [`ArrayBuffer`], [`SharedArrayBuffer`], or the `.buffer` property of a [`TypedArray`]. ",
                      "name": "arrayBuffer",
                      "type": "ArrayBuffer|SharedArrayBuffer",
                      "desc": "An [`ArrayBuffer`], [`SharedArrayBuffer`], or the `.buffer` property of a [`TypedArray`]."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Index of first byte to expose. **Default:** `0`. ",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Index of first byte to expose.",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {integer} Number of bytes to expose. **Default:** `arrayBuffer.length - byteOffset`. ",
                      "name": "length",
                      "type": "integer",
                      "default": "`arrayBuffer.length - byteOffset`",
                      "desc": "Number of bytes to expose.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "arrayBuffer"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>This creates a view of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> without copying the underlying\nmemory. For example, when passed a reference to the <code>.buffer</code> property of a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance, the newly created <code>Buffer</code> will share the same\nallocated memory as the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>.</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`\nconst buf = Buffer.from(arr.buffer);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 88 13 a0 0f&gt;\n\n// Changing the original Uint16Array changes the Buffer also\narr[1] = 6000;\n\nconsole.log(buf);\n// Prints: &lt;Buffer 88 13 70 17&gt;\n</code></pre>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<pre><code class=\"lang-js\">const ab = new ArrayBuffer(10);\nconst buf = Buffer.from(ab, 0, 2);\n\nconsole.log(buf.length);\n// Prints: 2\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> or a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a>.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(buffer)",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`buffer` {Buffer|Uint8Array} An existing `Buffer` or [`Uint8Array`] from which to copy data. ",
                      "name": "buffer",
                      "type": "Buffer|Uint8Array",
                      "desc": "An existing `Buffer` or [`Uint8Array`] from which to copy data."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "buffer"
                    }
                  ]
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;buffer&#39;);\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61;\n\nconsole.log(buf1.toString());\n// Prints: auffer\nconsole.log(buf2.toString());\n// Prints: buffer\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code>.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(string[, encoding])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`string` {string} A string to encode. ",
                      "name": "string",
                      "type": "string",
                      "desc": "A string to encode."
                    },
                    {
                      "textRaw": "`encoding` {string} The encoding of `string`. **Default:** `'utf8'`. ",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The encoding of `string`.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Creates a new <code>Buffer</code> containing <code>string</code>. The <code>encoding</code> parameter identifies\nthe character encoding of <code>string</code>.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;this is a tést&#39;);\nconst buf2 = Buffer.from(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\n\nconsole.log(buf1.toString());\n// Prints: this is a tést\nconsole.log(buf2.toString());\n// Prints: this is a tést\nconsole.log(buf1.toString(&#39;ascii&#39;));\n// Prints: this is a tC)st\n</code></pre>\n<p>A <code>TypeError</code> will be thrown if <code>string</code> is not a string.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.from(object[, offsetOrEncoding[, length]])",
              "type": "classMethod",
              "name": "from",
              "meta": {
                "added": [
                  "v8.2.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`object` {Object} An object supporting `Symbol.toPrimitive` or `valueOf()` ",
                      "name": "object",
                      "type": "Object",
                      "desc": "An object supporting `Symbol.toPrimitive` or `valueOf()`"
                    },
                    {
                      "textRaw": "`offsetOrEncoding` {number|string} A byte-offset or encoding, depending on the value returned either by `object.valueOf()` or `object[Symbol.toPrimitive]()`. ",
                      "name": "offsetOrEncoding",
                      "type": "number|string",
                      "desc": "A byte-offset or encoding, depending on the value returned either by `object.valueOf()` or `object[Symbol.toPrimitive]()`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {number} A length, depending on the value returned either by `object.valueOf()` or `object[Symbol.toPrimitive]()`. ",
                      "name": "length",
                      "type": "number",
                      "desc": "A length, depending on the value returned either by `object.valueOf()` or `object[Symbol.toPrimitive]()`.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "object"
                    },
                    {
                      "name": "offsetOrEncoding",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>For objects whose <code>valueOf()</code> function returns a value not strictly equal to\n<code>object</code>, returns <code>Buffer.from(object.valueOf(), offsetOrEncoding, length)</code>.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(new String(&#39;this is a test&#39;));\n// Prints: &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;\n</code></pre>\n<p>For objects that support <code>Symbol.toPrimitive</code>, returns\n<code>Buffer.from(object[Symbol.toPrimitive](), offsetOrEncoding, length)</code>.</p>\n<pre><code class=\"lang-js\">class Foo {\n  [Symbol.toPrimitive]() {\n    return &#39;this is a test&#39;;\n  }\n}\n\nconst buf = Buffer.from(new Foo(), &#39;utf8&#39;);\n// Prints: &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "Class Method: Buffer.isBuffer(obj)",
              "type": "classMethod",
              "name": "isBuffer",
              "meta": {
                "added": [
                  "v0.1.101"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} ",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`obj` {Object} ",
                      "name": "obj",
                      "type": "Object"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "obj"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if <code>obj</code> is a <code>Buffer</code>, <code>false</code> otherwise.</p>\n"
            },
            {
              "textRaw": "Class Method: Buffer.isEncoding(encoding)",
              "type": "classMethod",
              "name": "isEncoding",
              "meta": {
                "added": [
                  "v0.9.1"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} ",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {string} A character encoding name to check. ",
                      "name": "encoding",
                      "type": "string",
                      "desc": "A character encoding name to check."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if <code>encoding</code> contains a supported character encoding, or <code>false</code>\notherwise.</p>\n"
            }
          ],
          "properties": [
            {
              "textRaw": "`poolSize` {integer} **Default:** `8192` ",
              "type": "integer",
              "name": "poolSize",
              "meta": {
                "added": [
                  "v0.11.3"
                ],
                "changes": []
              },
              "default": "`8192`",
              "desc": "<p>This is the size (in bytes) of pre-allocated internal <code>Buffer</code> instances used\nfor pooling. This value may be modified.</p>\n"
            },
            {
              "textRaw": "buf[index]",
              "name": "[index]",
              "meta": {
                "type": "property",
                "name": [
                  "index"
                ],
                "changes": []
              },
              "desc": "<p>The index operator <code>[index]</code> can be used to get and set the octet at position\n<code>index</code> in <code>buf</code>. The values refer to individual bytes, so the legal value\nrange is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p>\n<p>This operator is inherited from <code>Uint8Array</code>, so its behavior on out-of-bounds\naccess is the same as <code>UInt8Array</code> - that is, getting returns <code>undefined</code> and\nsetting does nothing.</p>\n<pre><code class=\"lang-js\">// Copy an ASCII string into a `Buffer` one byte at a time.\n\nconst str = &#39;Node.js&#39;;\nconst buf = Buffer.allocUnsafe(str.length);\n\nfor (let i = 0; i &lt; str.length; i++) {\n  buf[i] = str.charCodeAt(i);\n}\n\nconsole.log(buf.toString(&#39;ascii&#39;));\n// Prints: Node.js\n</code></pre>\n"
            },
            {
              "textRaw": "`buffer` {ArrayBuffer} The underlying `ArrayBuffer` object based on which this `Buffer` object is created. ",
              "type": "ArrayBuffer",
              "name": "buffer",
              "desc": "<pre><code class=\"lang-js\">const arrayBuffer = new ArrayBuffer(16);\nconst buffer = Buffer.from(arrayBuffer);\n\nconsole.log(buffer.buffer === arrayBuffer);\n// Prints: true\n</code></pre>\n",
              "shortDesc": "The underlying `ArrayBuffer` object based on which this `Buffer` object is created."
            },
            {
              "textRaw": "`length` {integer} ",
              "type": "integer",
              "name": "length",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "desc": "<p>Returns the amount of memory allocated for <code>buf</code> in bytes. Note that this\ndoes not necessarily reflect the amount of &quot;usable&quot; data within <code>buf</code>.</p>\n<pre><code class=\"lang-js\">// Create a `Buffer` and write a shorter ASCII string to it.\n\nconst buf = Buffer.alloc(1234);\n\nconsole.log(buf.length);\n// Prints: 1234\n\nbuf.write(&#39;some string&#39;, 0, &#39;ascii&#39;);\n\nconsole.log(buf.length);\n// Prints: 1234\n</code></pre>\n<p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>\ncan result in undefined and inconsistent behavior. Applications that wish to\nmodify the length of a <code>Buffer</code> should therefore treat <code>length</code> as read-only and\nuse <a href=\"#buffer_buf_slice_start_end\"><code>buf.slice()</code></a> to create a new <code>Buffer</code>.</p>\n<pre><code class=\"lang-js\">let buf = Buffer.allocUnsafe(10);\n\nbuf.write(&#39;abcdefghj&#39;, 0, &#39;ascii&#39;);\n\nconsole.log(buf.length);\n// Prints: 10\n\nbuf = buf.slice(0, 5);\n\nconsole.log(buf.length);\n// Prints: 5\n</code></pre>\n"
            },
            {
              "textRaw": "buf.parent",
              "name": "parent",
              "meta": {
                "deprecated": [
                  "v8.0.0"
                ],
                "changes": []
              },
              "stability": 0,
              "stabilityText": "Deprecated: Use [`buf.buffer`] instead.",
              "desc": "<p>The <code>buf.parent</code> property is a deprecated alias for <code>buf.buffer</code>.</p>\n"
            }
          ],
          "methods": [
            {
              "textRaw": "buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])",
              "type": "method",
              "name": "compare",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The `target` parameter can now be a `Uint8Array`."
                  },
                  {
                    "version": "v5.11.0",
                    "pr-url": "https://github.com/nodejs/node/pull/5880",
                    "description": "Additional parameters for specifying offsets are supported now."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`target` {Buffer|Uint8Array} A `Buffer` or [`Uint8Array`] with which to compare `buf`. ",
                      "name": "target",
                      "type": "Buffer|Uint8Array",
                      "desc": "A `Buffer` or [`Uint8Array`] with which to compare `buf`."
                    },
                    {
                      "textRaw": "`targetStart` {integer} The offset within `target` at which to begin comparison. **Default:** `0`. ",
                      "name": "targetStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `target` at which to begin comparison.",
                      "optional": true
                    },
                    {
                      "textRaw": "`targetEnd` {integer} The offset with `target` at which to end comparison (not inclusive). **Default:** `target.length`. ",
                      "name": "targetEnd",
                      "type": "integer",
                      "default": "`target.length`",
                      "desc": "The offset with `target` at which to end comparison (not inclusive).",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` {integer} The offset within `buf` at which to begin comparison. **Default:** `0`. ",
                      "name": "sourceStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `buf` at which to begin comparison.",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` {integer} The offset within `buf` at which to end comparison (not inclusive). **Default:** [`buf.length`]. ",
                      "name": "sourceEnd",
                      "type": "integer",
                      "default": "[`buf.length`]",
                      "desc": "The offset within `buf` at which to end comparison (not inclusive).",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "target"
                    },
                    {
                      "name": "targetStart",
                      "optional": true
                    },
                    {
                      "name": "targetEnd",
                      "optional": true
                    },
                    {
                      "name": "sourceStart",
                      "optional": true
                    },
                    {
                      "name": "sourceEnd",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Compares <code>buf</code> with <code>target</code> and returns a number indicating whether <code>buf</code>\ncomes before, after, or is the same as <code>target</code> in sort order.\nComparison is based on the actual sequence of bytes in each <code>Buffer</code>.</p>\n<ul>\n<li><code>0</code> is returned if <code>target</code> is the same as <code>buf</code></li>\n<li><code>1</code> is returned if <code>target</code> should come <em>before</em> <code>buf</code> when sorted.</li>\n<li><code>-1</code> is returned if <code>target</code> should come <em>after</em> <code>buf</code> when sorted.</li>\n</ul>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;ABC&#39;);\nconst buf2 = Buffer.from(&#39;BCD&#39;);\nconst buf3 = Buffer.from(&#39;ABCD&#39;);\n\nconsole.log(buf1.compare(buf1));\n// Prints: 0\nconsole.log(buf1.compare(buf2));\n// Prints: -1\nconsole.log(buf1.compare(buf3));\n// Prints: -1\nconsole.log(buf2.compare(buf1));\n// Prints: 1\nconsole.log(buf2.compare(buf3));\n// Prints: 1\nconsole.log([buf1, buf2, buf3].sort(Buffer.compare));\n// Prints: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]\n// (This result is equal to: [buf1, buf3, buf2])\n</code></pre>\n<p>The optional <code>targetStart</code>, <code>targetEnd</code>, <code>sourceStart</code>, and <code>sourceEnd</code>\narguments can be used to limit the comparison to specific ranges within <code>target</code>\nand <code>buf</code> respectively.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\nconst buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n\nconsole.log(buf1.compare(buf2, 5, 9, 0, 4));\n// Prints: 0\nconsole.log(buf1.compare(buf2, 0, 6, 4));\n// Prints: -1\nconsole.log(buf1.compare(buf2, 5, 6, 5));\n// Prints: 1\n</code></pre>\n<p><a href=\"errors.html#ERR_INDEX_OUT_OF_RANGE\"><code>ERR_INDEX_OUT_OF_RANGE</code></a> is thrown if <code>targetStart &lt; 0</code>, <code>sourceStart &lt; 0</code>,\n<code>targetEnd &gt; target.byteLength</code>, or <code>sourceEnd &gt; source.byteLength</code>.</p>\n"
            },
            {
              "textRaw": "buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])",
              "type": "method",
              "name": "copy",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The number of bytes copied. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "The number of bytes copied."
                  },
                  "params": [
                    {
                      "textRaw": "`target` {Buffer|Uint8Array} A `Buffer` or [`Uint8Array`] to copy into. ",
                      "name": "target",
                      "type": "Buffer|Uint8Array",
                      "desc": "A `Buffer` or [`Uint8Array`] to copy into."
                    },
                    {
                      "textRaw": "`targetStart` {integer} The offset within `target` at which to begin writing. **Default:** `0`. ",
                      "name": "targetStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `target` at which to begin writing.",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceStart` {integer} The offset within `buf` from which to begin copying. **Default:** `0`. ",
                      "name": "sourceStart",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The offset within `buf` from which to begin copying.",
                      "optional": true
                    },
                    {
                      "textRaw": "`sourceEnd` {integer} The offset within `buf` at which to stop copying (not inclusive). **Default:** [`buf.length`]. ",
                      "name": "sourceEnd",
                      "type": "integer",
                      "default": "[`buf.length`]",
                      "desc": "The offset within `buf` at which to stop copying (not inclusive).",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "target"
                    },
                    {
                      "name": "targetStart",
                      "optional": true
                    },
                    {
                      "name": "sourceStart",
                      "optional": true
                    },
                    {
                      "name": "sourceEnd",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Copies data from a region of <code>buf</code> to a region in <code>target</code> even if the <code>target</code>\nmemory region overlaps with <code>buf</code>.</p>\n<pre><code class=\"lang-js\">// Create two `Buffer` instances.\nconst buf1 = Buffer.allocUnsafe(26);\nconst buf2 = Buffer.allocUnsafe(26).fill(&#39;!&#39;);\n\nfor (let i = 0; i &lt; 26; i++) {\n  // 97 is the decimal ASCII value for &#39;a&#39;\n  buf1[i] = i + 97;\n}\n\n// Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`\nbuf1.copy(buf2, 8, 16, 20);\n\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, 25));\n// Prints: !!!!!!!!qrst!!!!!!!!!!!!!\n</code></pre>\n<pre><code class=\"lang-js\">// Create a `Buffer` and copy data from one region to an overlapping region\n// within the same `Buffer`.\n\nconst buf = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &lt; 26; i++) {\n  // 97 is the decimal ASCII value for &#39;a&#39;\n  buf[i] = i + 97;\n}\n\nbuf.copy(buf, 0, 4, 10);\n\nconsole.log(buf.toString());\n// Prints: efghijghijklmnopqrstuvwxyz\n</code></pre>\n"
            },
            {
              "textRaw": "buf.entries()",
              "type": "method",
              "name": "entries",
              "meta": {
                "added": [
                  "v1.1.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator} ",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> of <code>[index, byte]</code> pairs from the contents of\n<code>buf</code>.</p>\n<pre><code class=\"lang-js\">// Log the entire contents of a `Buffer`.\n\nconst buf = Buffer.from(&#39;buffer&#39;);\n\nfor (const pair of buf.entries()) {\n  console.log(pair);\n}\n// Prints:\n//   [0, 98]\n//   [1, 117]\n//   [2, 102]\n//   [3, 102]\n//   [4, 101]\n//   [5, 114]\n</code></pre>\n"
            },
            {
              "textRaw": "buf.equals(otherBuffer)",
              "type": "method",
              "name": "equals",
              "meta": {
                "added": [
                  "v0.11.13"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The arguments can now be `Uint8Array`s."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} ",
                    "name": "return",
                    "type": "boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`otherBuffer` {Buffer} A `Buffer` or [`Uint8Array`] with which to compare `buf`. ",
                      "name": "otherBuffer",
                      "type": "Buffer",
                      "desc": "A `Buffer` or [`Uint8Array`] with which to compare `buf`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "otherBuffer"
                    }
                  ]
                }
              ],
              "desc": "<p>Returns <code>true</code> if both <code>buf</code> and <code>otherBuffer</code> have exactly the same bytes,\n<code>false</code> otherwise.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from(&#39;ABC&#39;);\nconst buf2 = Buffer.from(&#39;414243&#39;, &#39;hex&#39;);\nconst buf3 = Buffer.from(&#39;ABCD&#39;);\n\nconsole.log(buf1.equals(buf2));\n// Prints: true\nconsole.log(buf1.equals(buf3));\n// Prints: false\n</code></pre>\n"
            },
            {
              "textRaw": "buf.fill(value[, offset[, end]][, encoding])",
              "type": "method",
              "name": "fill",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18790",
                    "description": "Negative `end` values throw an `ERR_INDEX_OUT_OF_RANGE` error."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18129",
                    "description": "Attempting to fill a non-zero length buffer with a zero length buffer triggers a thrown exception."
                  },
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/17427",
                    "description": "Specifying an invalid string for `value` triggers a thrown exception."
                  },
                  {
                    "version": "v5.7.0",
                    "pr-url": "https://github.com/nodejs/node/pull/4935",
                    "description": "The `encoding` parameter is supported now."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`. ",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|integer} The value with which to fill `buf`. ",
                      "name": "value",
                      "type": "string|Buffer|integer",
                      "desc": "The value with which to fill `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to fill `buf`. **Default:** `0`. ",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to fill `buf`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {integer} Where to stop filling `buf` (not inclusive). **Default:** [`buf.length`]. ",
                      "name": "end",
                      "type": "integer",
                      "default": "[`buf.length`]",
                      "desc": "Where to stop filling `buf` (not inclusive).",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} The encoding for `value` if `value` is a string. **Default:** `'utf8'`. ",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The encoding for `value` if `value` is a string.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Fills <code>buf</code> with the specified <code>value</code>. If the <code>offset</code> and <code>end</code> are not given,\nthe entire <code>buf</code> will be filled:</p>\n<pre><code class=\"lang-js\">// Fill a `Buffer` with the ASCII character &#39;h&#39;.\n\nconst b = Buffer.allocUnsafe(50).fill(&#39;h&#39;);\n\nconsole.log(b.toString());\n// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\n</code></pre>\n<p><code>value</code> is coerced to a <code>uint32</code> value if it is not a string or integer.</p>\n<p>If the final write of a <code>fill()</code> operation falls on a multi-byte character,\nthen only the bytes of that character that fit into <code>buf</code> are written:</p>\n<pre><code class=\"lang-js\">// Fill a `Buffer` with a two-byte character.\n\nconsole.log(Buffer.allocUnsafe(3).fill(&#39;\\u0222&#39;));\n// Prints: &lt;Buffer c8 a2 c8&gt;\n</code></pre>\n<p>If <code>value</code> contains invalid characters, it is truncated; if no valid\nfill data remains, an exception is thrown:</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(5);\n\nconsole.log(buf.fill(&#39;a&#39;));\n// Prints: &lt;Buffer 61 61 61 61 61&gt;\nconsole.log(buf.fill(&#39;aazz&#39;, &#39;hex&#39;));\n// Prints: &lt;Buffer aa aa aa aa aa&gt;\nconsole.log(buf.fill(&#39;zz&#39;, &#39;hex&#39;));\n// Throws an exception.\n</code></pre>\n"
            },
            {
              "textRaw": "buf.includes(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "includes",
              "meta": {
                "added": [
                  "v5.3.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {boolean} `true` if `value` was found in `buf`, `false` otherwise. ",
                    "name": "return",
                    "type": "boolean",
                    "desc": "`true` if `value` was found in `buf`, `false` otherwise."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|integer} What to search for. ",
                      "name": "value",
                      "type": "string|Buffer|integer",
                      "desc": "What to search for."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Where to begin searching in `buf`. **Default:** `0`. ",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Where to begin searching in `buf`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} If `value` is a string, this is its encoding. **Default:** `'utf8'`. ",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `value` is a string, this is its encoding.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Equivalent to <a href=\"#buffer_buf_indexof_value_byteoffset_encoding\"><code>buf.indexOf() !== -1</code></a>.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;this is a buffer&#39;);\n\nconsole.log(buf.includes(&#39;this&#39;));\n// Prints: true\nconsole.log(buf.includes(&#39;is&#39;));\n// Prints: true\nconsole.log(buf.includes(Buffer.from(&#39;a buffer&#39;)));\n// Prints: true\nconsole.log(buf.includes(97));\n// Prints: true (97 is the decimal ASCII value for &#39;a&#39;)\nconsole.log(buf.includes(Buffer.from(&#39;a buffer example&#39;)));\n// Prints: false\nconsole.log(buf.includes(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));\n// Prints: true\nconsole.log(buf.includes(&#39;this&#39;, 4));\n// Prints: false\n</code></pre>\n"
            },
            {
              "textRaw": "buf.indexOf(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "indexOf",
              "meta": {
                "added": [
                  "v1.5.0"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The `value` can now be a `Uint8Array`."
                  },
                  {
                    "version": "v5.7.0, v4.4.0",
                    "pr-url": "https://github.com/nodejs/node/pull/4803",
                    "description": "When `encoding` is being passed, the `byteOffset` parameter is no longer required."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|Uint8Array|integer} What to search for. ",
                      "name": "value",
                      "type": "string|Buffer|Uint8Array|integer",
                      "desc": "What to search for."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Where to begin searching in `buf`. **Default:** `0`. ",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Where to begin searching in `buf`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`. **Default:** `'utf8'`. ",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>If <code>value</code> is:</p>\n<ul>\n<li>a string, <code>value</code> is interpreted according to the character encoding in\n<code>encoding</code>.</li>\n<li>a <code>Buffer</code> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\"><code>Uint8Array</code></a>, <code>value</code> will be used in its entirety.\nTo compare a partial <code>Buffer</code>, use <a href=\"#buffer_buf_slice_start_end\"><code>buf.slice()</code></a>.</li>\n<li>a number, <code>value</code> will be interpreted as an unsigned 8-bit integer\nvalue between <code>0</code> and <code>255</code>.</li>\n</ul>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;this is a buffer&#39;);\n\nconsole.log(buf.indexOf(&#39;this&#39;));\n// Prints: 0\nconsole.log(buf.indexOf(&#39;is&#39;));\n// Prints: 2\nconsole.log(buf.indexOf(Buffer.from(&#39;a buffer&#39;)));\n// Prints: 8\nconsole.log(buf.indexOf(97));\n// Prints: 8 (97 is the decimal ASCII value for &#39;a&#39;)\nconsole.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;)));\n// Prints: -1\nconsole.log(buf.indexOf(Buffer.from(&#39;a buffer example&#39;).slice(0, 8)));\n// Prints: 8\n\nconst utf16Buffer = Buffer.from(&#39;\\u039a\\u0391\\u03a3\\u03a3\\u0395&#39;, &#39;utf16le&#39;);\n\nconsole.log(utf16Buffer.indexOf(&#39;\\u03a3&#39;, 0, &#39;utf16le&#39;));\n// Prints: 4\nconsole.log(utf16Buffer.indexOf(&#39;\\u03a3&#39;, -4, &#39;utf16le&#39;));\n// Prints: 6\n</code></pre>\n<p>If <code>value</code> is not a string, number, or <code>Buffer</code>, this method will throw a\n<code>TypeError</code>. If <code>value</code> is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.</p>\n<p>If <code>byteOffset</code> is not a number, it will be coerced to a number. If the result\nof coercion is <code>NaN</code> or <code>0</code>, then the entire buffer will be searched. This\nbehavior matches <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf\"><code>String#indexOf()</code></a>.</p>\n<pre><code class=\"lang-js\">const b = Buffer.from(&#39;abcdef&#39;);\n\n// Passing a value that&#39;s a number, but not a valid byte\n// Prints: 2, equivalent to searching for 99 or &#39;c&#39;\nconsole.log(b.indexOf(99.9));\nconsole.log(b.indexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN or 0\n// Prints: 1, searching the whole buffer\nconsole.log(b.indexOf(&#39;b&#39;, undefined));\nconsole.log(b.indexOf(&#39;b&#39;, {}));\nconsole.log(b.indexOf(&#39;b&#39;, null));\nconsole.log(b.indexOf(&#39;b&#39;, []));\n</code></pre>\n<p>If <code>value</code> is an empty string or empty <code>Buffer</code> and <code>byteOffset</code> is less\nthan <code>buf.length</code>, <code>byteOffset</code> will be returned. If <code>value</code> is empty and\n<code>byteOffset</code> is at least <code>buf.length</code>, <code>buf.length</code> will be returned.</p>\n"
            },
            {
              "textRaw": "buf.keys()",
              "type": "method",
              "name": "keys",
              "meta": {
                "added": [
                  "v1.1.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator} ",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> of <code>buf</code> keys (indices).</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\nfor (const key of buf.keys()) {\n  console.log(key);\n}\n// Prints:\n//   0\n//   1\n//   2\n//   3\n//   4\n//   5\n</code></pre>\n"
            },
            {
              "textRaw": "buf.lastIndexOf(value[, byteOffset][, encoding])",
              "type": "method",
              "name": "lastIndexOf",
              "meta": {
                "added": [
                  "v6.0.0"
                ],
                "changes": [
                  {
                    "version": "v8.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/10236",
                    "description": "The `value` can now be a `Uint8Array`."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {string|Buffer|Uint8Array|integer} What to search for. ",
                      "name": "value",
                      "type": "string|Buffer|Uint8Array|integer",
                      "desc": "What to search for."
                    },
                    {
                      "textRaw": "`byteOffset` {integer} Where to begin searching in `buf`. **Default:** [`buf.length`]` - 1`. ",
                      "name": "byteOffset",
                      "type": "integer",
                      "default": "[`buf.length`]` - 1`",
                      "desc": "Where to begin searching in `buf`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`. **Default:** `'utf8'`. ",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "byteOffset",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Identical to <a href=\"#buffer_buf_indexof_value_byteoffset_encoding\"><code>buf.indexOf()</code></a>, except the last occurrence of <code>value</code> is found\nrather than the first occurrence.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;this buffer is a buffer&#39;);\n\nconsole.log(buf.lastIndexOf(&#39;this&#39;));\n// Prints: 0\nconsole.log(buf.lastIndexOf(&#39;buffer&#39;));\n// Prints: 17\nconsole.log(buf.lastIndexOf(Buffer.from(&#39;buffer&#39;)));\n// Prints: 17\nconsole.log(buf.lastIndexOf(97));\n// Prints: 15 (97 is the decimal ASCII value for &#39;a&#39;)\nconsole.log(buf.lastIndexOf(Buffer.from(&#39;yolo&#39;)));\n// Prints: -1\nconsole.log(buf.lastIndexOf(&#39;buffer&#39;, 5));\n// Prints: 5\nconsole.log(buf.lastIndexOf(&#39;buffer&#39;, 4));\n// Prints: -1\n\nconst utf16Buffer = Buffer.from(&#39;\\u039a\\u0391\\u03a3\\u03a3\\u0395&#39;, &#39;utf16le&#39;);\n\nconsole.log(utf16Buffer.lastIndexOf(&#39;\\u03a3&#39;, undefined, &#39;utf16le&#39;));\n// Prints: 6\nconsole.log(utf16Buffer.lastIndexOf(&#39;\\u03a3&#39;, -5, &#39;utf16le&#39;));\n// Prints: 4\n</code></pre>\n<p>If <code>value</code> is not a string, number, or <code>Buffer</code>, this method will throw a\n<code>TypeError</code>. If <code>value</code> is a number, it will be coerced to a valid byte value,\nan integer between 0 and 255.</p>\n<p>If <code>byteOffset</code> is not a number, it will be coerced to a number. Any arguments\nthat coerce to <code>NaN</code>, like <code>{}</code> or <code>undefined</code>, will search the whole buffer.\nThis behavior matches <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf\"><code>String#lastIndexOf()</code></a>.</p>\n<pre><code class=\"lang-js\">const b = Buffer.from(&#39;abcdef&#39;);\n\n// Passing a value that&#39;s a number, but not a valid byte\n// Prints: 2, equivalent to searching for 99 or &#39;c&#39;\nconsole.log(b.lastIndexOf(99.9));\nconsole.log(b.lastIndexOf(256 + 99));\n\n// Passing a byteOffset that coerces to NaN\n// Prints: 1, searching the whole buffer\nconsole.log(b.lastIndexOf(&#39;b&#39;, undefined));\nconsole.log(b.lastIndexOf(&#39;b&#39;, {}));\n\n// Passing a byteOffset that coerces to 0\n// Prints: -1, equivalent to passing 0\nconsole.log(b.lastIndexOf(&#39;b&#39;, null));\nconsole.log(b.lastIndexOf(&#39;b&#39;, []));\n</code></pre>\n<p>If <code>value</code> is an empty string or empty <code>Buffer</code>, <code>byteOffset</code> will be returned.</p>\n"
            },
            {
              "textRaw": "buf.readDoubleBE(offset)",
              "type": "method",
              "name": "readDoubleBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number} ",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns\nlittle endian).</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readDoubleLE(offset)",
              "type": "method",
              "name": "readDoubleLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number} ",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns\nlittle endian).</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n\nconsole.log(buf.readDoubleBE(0));\n// Prints: 8.20788039913184e-304\nconsole.log(buf.readDoubleLE(0));\n// Prints: 5.447603722011605e-270\nconsole.log(buf.readDoubleLE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatBE(offset)",
              "type": "method",
              "name": "readFloatBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number} ",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns\nlittle endian).</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readFloatLE(offset)",
              "type": "method",
              "name": "readFloatLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {number} ",
                    "name": "return",
                    "type": "number"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified\nendian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns\nlittle endian).</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, 2, 3, 4]);\n\nconsole.log(buf.readFloatBE(0));\n// Prints: 2.387939260590663e-38\nconsole.log(buf.readFloatLE(0));\n// Prints: 1.539989614439558e-36\nconsole.log(buf.readFloatLE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt8(offset)",
              "type": "method",
              "name": "readInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([-1, 5]);\n\nconsole.log(buf.readInt8(0));\n// Prints: -1\nconsole.log(buf.readInt8(1));\n// Prints: 5\nconsole.log(buf.readInt8(2));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt16BE(offset)",
              "type": "method",
              "name": "readInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt16BE()</code> returns big endian,\n<code>readInt16LE()</code> returns little endian).</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt16LE(offset)",
              "type": "method",
              "name": "readInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt16BE()</code> returns big endian,\n<code>readInt16LE()</code> returns little endian).</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 5]);\n\nconsole.log(buf.readInt16BE(0));\n// Prints: 5\nconsole.log(buf.readInt16LE(0));\n// Prints: 1280\nconsole.log(buf.readInt16LE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt32BE(offset)",
              "type": "method",
              "name": "readInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt32BE()</code> returns big endian,\n<code>readInt32LE()</code> returns little endian).</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readInt32LE(offset)",
              "type": "method",
              "name": "readInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nthe specified endian format (<code>readInt32BE()</code> returns big endian,\n<code>readInt32LE()</code> returns little endian).</p>\n<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0, 0, 0, 5]);\n\nconsole.log(buf.readInt32BE(0));\n// Prints: 5\nconsole.log(buf.readInt32LE(0));\n// Prints: 83886080\nconsole.log(buf.readInt32LE(1));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readIntBE(offset, byteLength)",
              "type": "method",
              "name": "readIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`. ",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as a two&#39;s complement signed value. Supports up to 48\nbits of accuracy.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_INDEX_OUT_OF_RANGE\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readIntLE(offset, byteLength)",
              "type": "method",
              "name": "readIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`. ",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as a two&#39;s complement signed value. Supports up to 48\nbits of accuracy.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readIntLE(0, 6).toString(16));\n// Prints: -546f87a9cbee\nconsole.log(buf.readIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readIntBE(1, 6).toString(16));\n// Throws ERR_INDEX_OUT_OF_RANGE\nconsole.log(buf.readIntBE(1, 0).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt8(offset)",
              "type": "method",
              "name": "readUInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([1, -2]);\n\nconsole.log(buf.readUInt8(0));\n// Prints: 1\nconsole.log(buf.readUInt8(1));\n// Prints: 254\nconsole.log(buf.readUInt8(2));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16BE(offset)",
              "type": "method",
              "name": "readUInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>\nreturns little endian).</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt16LE(offset)",
              "type": "method",
              "name": "readUInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>\nreturns little endian).</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56]);\n\nconsole.log(buf.readUInt16BE(0).toString(16));\n// Prints: 1234\nconsole.log(buf.readUInt16LE(0).toString(16));\n// Prints: 3412\nconsole.log(buf.readUInt16BE(1).toString(16));\n// Prints: 3456\nconsole.log(buf.readUInt16LE(1).toString(16));\n// Prints: 5634\nconsole.log(buf.readUInt16LE(2).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32BE(offset)",
              "type": "method",
              "name": "readUInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt32BE()</code> returns big endian,\n<code>readUInt32LE()</code> returns little endian).</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUInt32LE(offset)",
              "type": "method",
              "name": "readUInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with\nspecified endian format (<code>readUInt32BE()</code> returns big endian,\n<code>readUInt32LE()</code> returns little endian).</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n\nconsole.log(buf.readUInt32BE(0).toString(16));\n// Prints: 12345678\nconsole.log(buf.readUInt32LE(0).toString(16));\n// Prints: 78563412\nconsole.log(buf.readUInt32LE(1).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUIntBE(offset, byteLength)",
              "type": "method",
              "name": "readUIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`. ",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as an unsigned integer. Supports up to 48\nbits of accuracy.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.readUIntLE(offset, byteLength)",
              "type": "method",
              "name": "readUIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} ",
                    "name": "return",
                    "type": "integer"
                  },
                  "params": [
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to read. Must satisfy `0 < byteLength <= 6`. ",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to read. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                }
              ],
              "desc": "<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>\nand interprets the result as an unsigned integer. Supports up to 48\nbits of accuracy.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n\nconsole.log(buf.readUIntBE(0, 6).toString(16));\n// Prints: 1234567890ab\nconsole.log(buf.readUIntLE(0, 6).toString(16));\n// Prints: ab9078563412\nconsole.log(buf.readUIntBE(1, 6).toString(16));\n// Throws ERR_OUT_OF_RANGE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.slice([start[, end]])",
              "type": "method",
              "name": "slice",
              "meta": {
                "added": [
                  "v0.3.0"
                ],
                "changes": [
                  {
                    "version": "v7.1.0, v6.9.2",
                    "pr-url": "https://github.com/nodejs/node/pull/9341",
                    "description": "Coercing the offsets to integers now handles values outside the 32-bit integer range properly."
                  },
                  {
                    "version": "v7.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/9101",
                    "description": "All offsets are now coerced to integers before doing any calculations with them."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} ",
                    "name": "return",
                    "type": "Buffer"
                  },
                  "params": [
                    {
                      "textRaw": "`start` {integer} Where the new `Buffer` will start. **Default:** `0`. ",
                      "name": "start",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Where the new `Buffer` will start.",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {integer} Where the new `Buffer` will end (not inclusive). **Default:** [`buf.length`]. ",
                      "name": "end",
                      "type": "integer",
                      "default": "[`buf.length`]",
                      "desc": "Where the new `Buffer` will end (not inclusive).",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Returns a new <code>Buffer</code> that references the same memory as the original, but\noffset and cropped by the <code>start</code> and <code>end</code> indices.</p>\n<p>Specifying <code>end</code> greater than <a href=\"#buffer_buf_length\"><code>buf.length</code></a> will return the same result as\nthat of <code>end</code> equal to <a href=\"#buffer_buf_length\"><code>buf.length</code></a>.</p>\n<p>Modifying the new <code>Buffer</code> slice will modify the memory in the original <code>Buffer</code>\nbecause the allocated memory of the two objects overlap.</p>\n<pre><code class=\"lang-js\">// Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n// from the original `Buffer`.\n\nconst buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &lt; 26; i++) {\n  // 97 is the decimal ASCII value for &#39;a&#39;\n  buf1[i] = i + 97;\n}\n\nconst buf2 = buf1.slice(0, 3);\n\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));\n// Prints: abc\n\nbuf1[0] = 33;\n\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));\n// Prints: !bc\n</code></pre>\n<p>Specifying negative indexes causes the slice to be generated relative to the\nend of <code>buf</code> rather than the beginning.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\nconsole.log(buf.slice(-6, -1).toString());\n// Prints: buffe\n// (Equivalent to buf.slice(0, 5))\n\nconsole.log(buf.slice(-6, -2).toString());\n// Prints: buff\n// (Equivalent to buf.slice(0, 4))\n\nconsole.log(buf.slice(-5, -2).toString());\n// Prints: uff\n// (Equivalent to buf.slice(1, 4))\n</code></pre>\n"
            },
            {
              "textRaw": "buf.swap16()",
              "type": "method",
              "name": "swap16",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`. ",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of unsigned 16-bit integers and swaps the\nbyte order <em>in-place</em>. Throws <a href=\"errors.html#ERR_INVALID_BUFFER_SIZE\"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href=\"#buffer_buf_length\"><code>buf.length</code></a> is\nnot a multiple of 2.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;\n\nbuf1.swap16();\n\nconsole.log(buf1);\n// Prints: &lt;Buffer 02 01 04 03 06 05 08 07&gt;\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap16();\n// Throws ERR_INVALID_BUFFER_SIZE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.swap32()",
              "type": "method",
              "name": "swap32",
              "meta": {
                "added": [
                  "v5.10.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`. ",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of unsigned 32-bit integers and swaps the\nbyte order <em>in-place</em>. Throws <a href=\"errors.html#ERR_INVALID_BUFFER_SIZE\"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href=\"#buffer_buf_length\"><code>buf.length</code></a> is\nnot a multiple of 4.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;\n\nbuf1.swap32();\n\nconsole.log(buf1);\n// Prints: &lt;Buffer 04 03 02 01 08 07 06 05&gt;\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap32();\n// Throws ERR_INVALID_BUFFER_SIZE\n</code></pre>\n"
            },
            {
              "textRaw": "buf.swap64()",
              "type": "method",
              "name": "swap64",
              "meta": {
                "added": [
                  "v6.3.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Buffer} A reference to `buf`. ",
                    "name": "return",
                    "type": "Buffer",
                    "desc": "A reference to `buf`."
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Interprets <code>buf</code> as an array of 64-bit numbers and swaps byte order <em>in-place</em>.\nThrows <a href=\"errors.html#ERR_INVALID_BUFFER_SIZE\"><code>ERR_INVALID_BUFFER_SIZE</code></a> if <a href=\"#buffer_buf_length\"><code>buf.length</code></a> is not a multiple of 8.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n\nconsole.log(buf1);\n// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;\n\nbuf1.swap64();\n\nconsole.log(buf1);\n// Prints: &lt;Buffer 08 07 06 05 04 03 02 01&gt;\n\nconst buf2 = Buffer.from([0x1, 0x2, 0x3]);\n\nbuf2.swap64();\n// Throws ERR_INVALID_BUFFER_SIZE\n</code></pre>\n<p>Note that JavaScript cannot encode 64-bit integers. This method is intended\nfor working with 64-bit floats.</p>\n"
            },
            {
              "textRaw": "buf.toJSON()",
              "type": "method",
              "name": "toJSON",
              "meta": {
                "added": [
                  "v0.9.2"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Object} ",
                    "name": "return",
                    "type": "Object"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Returns a JSON representation of <code>buf</code>. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\"><code>JSON.stringify()</code></a> implicitly calls\nthis function when stringifying a <code>Buffer</code> instance.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);\nconst json = JSON.stringify(buf);\n\nconsole.log(json);\n// Prints: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}\n\nconst copy = JSON.parse(json, (key, value) =&gt; {\n  return value &amp;&amp; value.type === &#39;Buffer&#39; ?\n    Buffer.from(value.data) :\n    value;\n});\n\nconsole.log(copy);\n// Prints: &lt;Buffer 01 02 03 04 05&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.toString([encoding[, start[, end]]])",
              "type": "method",
              "name": "toString",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {string} ",
                    "name": "return",
                    "type": "string"
                  },
                  "params": [
                    {
                      "textRaw": "`encoding` {string} The character encoding to use. **Default:** `'utf8'`. ",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The character encoding to use.",
                      "optional": true
                    },
                    {
                      "textRaw": "`start` {integer} The byte offset to start decoding at. **Default:** `0`. ",
                      "name": "start",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "The byte offset to start decoding at.",
                      "optional": true
                    },
                    {
                      "textRaw": "`end` {integer} The byte offset to stop decoding at (not inclusive). **Default:** [`buf.length`]. ",
                      "name": "end",
                      "type": "integer",
                      "default": "[`buf.length`]",
                      "desc": "The byte offset to stop decoding at (not inclusive).",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "start",
                      "optional": true
                    },
                    {
                      "name": "end",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Decodes <code>buf</code> to a string according to the specified character encoding in\n<code>encoding</code>. <code>start</code> and <code>end</code> may be passed to decode only a subset of <code>buf</code>.</p>\n<p>The maximum length of a string instance (in UTF-16 code units) is available\nas <a href=\"#buffer_buffer_constants_max_string_length\"><code>buffer.constants.MAX_STRING_LENGTH</code></a>.</p>\n<pre><code class=\"lang-js\">const buf1 = Buffer.allocUnsafe(26);\n\nfor (let i = 0; i &lt; 26; i++) {\n  // 97 is the decimal ASCII value for &#39;a&#39;\n  buf1[i] = i + 97;\n}\n\nconsole.log(buf1.toString(&#39;ascii&#39;));\n// Prints: abcdefghijklmnopqrstuvwxyz\nconsole.log(buf1.toString(&#39;ascii&#39;, 0, 5));\n// Prints: abcde\n\nconst buf2 = Buffer.from(&#39;tést&#39;);\n\nconsole.log(buf2.toString(&#39;hex&#39;));\n// Prints: 74c3a97374\nconsole.log(buf2.toString(&#39;utf8&#39;, 0, 3));\n// Prints: té\nconsole.log(buf2.toString(undefined, 0, 3));\n// Prints: té\n</code></pre>\n"
            },
            {
              "textRaw": "buf.values()",
              "type": "method",
              "name": "values",
              "meta": {
                "added": [
                  "v1.1.0"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {Iterator} ",
                    "name": "return",
                    "type": "Iterator"
                  },
                  "params": []
                },
                {
                  "params": []
                }
              ],
              "desc": "<p>Creates and returns an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">iterator</a> for <code>buf</code> values (bytes). This function is\ncalled automatically when a <code>Buffer</code> is used in a <code>for..of</code> statement.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.from(&#39;buffer&#39;);\n\nfor (const value of buf.values()) {\n  console.log(value);\n}\n// Prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\n\nfor (const value of buf) {\n  console.log(value);\n}\n// Prints:\n//   98\n//   117\n//   102\n//   102\n//   101\n//   114\n</code></pre>\n"
            },
            {
              "textRaw": "buf.write(string[, offset[, length]][, encoding])",
              "type": "method",
              "name": "write",
              "meta": {
                "added": [
                  "v0.1.90"
                ],
                "changes": []
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} Number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "Number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`string` {string} String to write to `buf`. ",
                      "name": "string",
                      "type": "string",
                      "desc": "String to write to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write `string`. **Default:** `0`. ",
                      "name": "offset",
                      "type": "integer",
                      "default": "`0`",
                      "desc": "Number of bytes to skip before starting to write `string`.",
                      "optional": true
                    },
                    {
                      "textRaw": "`length` {integer} Number of bytes to write. **Default:** `buf.length - offset`. ",
                      "name": "length",
                      "type": "integer",
                      "default": "`buf.length - offset`",
                      "desc": "Number of bytes to write.",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {string} The character encoding of `string`. **Default:** `'utf8'`. ",
                      "name": "encoding",
                      "type": "string",
                      "default": "`'utf8'`",
                      "desc": "The character encoding of `string`.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "string"
                    },
                    {
                      "name": "offset",
                      "optional": true
                    },
                    {
                      "name": "length",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>string</code> to <code>buf</code> at <code>offset</code> according to the character encoding in\n<code>encoding</code>. The <code>length</code> parameter is the number of bytes to write. If <code>buf</code> did\nnot contain enough space to fit the entire string, only part of <code>string</code> will be\nwritten. However, partially encoded characters will not be written.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.alloc(256);\n\nconst len = buf.write(&#39;\\u00bd + \\u00bc = \\u00be&#39;, 0);\n\nconsole.log(`${len} bytes: ${buf.toString(&#39;utf8&#39;, 0, len)}`);\n// Prints: 12 bytes: ½ + ¼ = ¾\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleBE(value, offset)",
              "type": "method",
              "name": "writeDoubleBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when\n<code>value</code> is anything other than a 64-bit double.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeDoubleLE(value, offset)",
              "type": "method",
              "name": "writeDoubleLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when\n<code>value</code> is anything other than a 64-bit double.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\n\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatBE(value, offset)",
              "type": "method",
              "name": "writeFloatBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when\n<code>value</code> is anything other than a 32-bit float.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 4f 4a fe bb&gt;\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer bb fe 4a 4f&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeFloatLE(value, offset)",
              "type": "method",
              "name": "writeFloatLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {number} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "number",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when\n<code>value</code> is anything other than a 32-bit float.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeFloatBE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 4f 4a fe bb&gt;\n\nbuf.writeFloatLE(0xcafebabe, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer bb fe 4a 4f&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt8(value, offset)",
              "type": "method",
              "name": "writeInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a valid\nsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything other than\na signed 8-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(2);\n\nbuf.writeInt8(2, 0);\nbuf.writeInt8(-2, 1);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 02 fe&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt16BE(value, offset)",
              "type": "method",
              "name": "writeInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is\nundefined when <code>value</code> is anything other than a signed 16-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt16BE(0x0102, 0);\nbuf.writeInt16LE(0x0304, 2);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 01 02 04 03&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt16LE(value, offset)",
              "type": "method",
              "name": "writeInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is\nundefined when <code>value</code> is anything other than a signed 16-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeInt16BE(0x0102, 0);\nbuf.writeInt16LE(0x0304, 2);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 01 02 04 03&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt32BE(value, offset)",
              "type": "method",
              "name": "writeInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is\nundefined when <code>value</code> is anything other than a signed 32-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeInt32BE(0x01020304, 0);\nbuf.writeInt32LE(0x05060708, 4);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeInt32LE(value, offset)",
              "type": "method",
              "name": "writeInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little\nendian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is\nundefined when <code>value</code> is anything other than a signed 32-bit integer.</p>\n<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(8);\n\nbuf.writeInt32BE(0x01020304, 0);\nbuf.writeInt32LE(0x05060708, 4);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeIntBE(value, offset, byteLength)",
              "type": "method",
              "name": "writeIntBE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`. ",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than a signed integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &lt;Buffer ab 90 78 56 34 12&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeIntLE(value, offset, byteLength)",
              "type": "method",
              "name": "writeIntLE",
              "meta": {
                "added": [
                  "v0.11.15"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`. ",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than a signed integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\n\nbuf.writeIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &lt;Buffer ab 90 78 56 34 12&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt8(value, offset)",
              "type": "method",
              "name": "writeUInt8",
              "meta": {
                "added": [
                  "v0.5.0"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a\nvalid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything\nother than an unsigned 8-bit integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt8(0x3, 0);\nbuf.writeUInt8(0x4, 1);\nbuf.writeUInt8(0x23, 2);\nbuf.writeUInt8(0x42, 3);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 03 04 23 42&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16BE(value, offset)",
              "type": "method",
              "name": "writeUInt16BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &lt;Buffer de ad be ef&gt;\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &lt;Buffer ad de ef be&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt16LE(value, offset)",
              "type": "method",
              "name": "writeUInt16LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt16BE(0xdead, 0);\nbuf.writeUInt16BE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &lt;Buffer de ad be ef&gt;\n\nbuf.writeUInt16LE(0xdead, 0);\nbuf.writeUInt16LE(0xbeef, 2);\n\nconsole.log(buf);\n// Prints: &lt;Buffer ad de ef be&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32BE(value, offset)",
              "type": "method",
              "name": "writeUInt32BE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer fe ed fa ce&gt;\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer ce fa ed fe&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUInt32LE(value, offset)",
              "type": "method",
              "name": "writeUInt32LE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian\nformat (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little\nendian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is\nundefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(4);\n\nbuf.writeUInt32BE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer fe ed fa ce&gt;\n\nbuf.writeUInt32LE(0xfeedface, 0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer ce fa ed fe&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUIntBE(value, offset, byteLength)",
              "type": "method",
              "name": "writeUIntBE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`. ",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than an unsigned integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &lt;Buffer ab 90 78 56 34 12&gt;\n</code></pre>\n"
            },
            {
              "textRaw": "buf.writeUIntLE(value, offset, byteLength)",
              "type": "method",
              "name": "writeUIntLE",
              "meta": {
                "added": [
                  "v0.5.5"
                ],
                "changes": [
                  {
                    "version": "v10.0.0",
                    "pr-url": "https://github.com/nodejs/node/pull/18395",
                    "description": "Removed `noAssert` and no implicit coercion of the offset and `byteLength` to `uint32` anymore."
                  }
                ]
              },
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns: {integer} `offset` plus the number of bytes written. ",
                    "name": "return",
                    "type": "integer",
                    "desc": "`offset` plus the number of bytes written."
                  },
                  "params": [
                    {
                      "textRaw": "`value` {integer} Number to be written to `buf`. ",
                      "name": "value",
                      "type": "integer",
                      "desc": "Number to be written to `buf`."
                    },
                    {
                      "textRaw": "`offset` {integer} Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`. ",
                      "name": "offset",
                      "type": "integer",
                      "desc": "Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`."
                    },
                    {
                      "textRaw": "`byteLength` {integer} Number of bytes to write. Must satisfy `0 < byteLength <= 6`. ",
                      "name": "byteLength",
                      "type": "integer",
                      "desc": "Number of bytes to write. Must satisfy `0 < byteLength <= 6`."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "value"
                    },
                    {
                      "name": "offset"
                    },
                    {
                      "name": "byteLength"
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.\nSupports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is\nanything other than an unsigned integer.</p>\n<pre><code class=\"lang-js\">const buf = Buffer.allocUnsafe(6);\n\nbuf.writeUIntBE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;\n\nbuf.writeUIntLE(0x1234567890ab, 0, 6);\n\nconsole.log(buf);\n// Prints: &lt;Buffer ab 90 78 56 34 12&gt;\n</code></pre>\n"
            }
          ],
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`array` {integer[]} An array of bytes to copy from. ",
                  "name": "array",
                  "type": "integer[]",
                  "desc": "An array of bytes to copy from."
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<pre><code class=\"lang-js\">// Creates a new Buffer containing the UTF-8 bytes of the string &#39;buffer&#39;\nconst buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "array"
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>\n<pre><code class=\"lang-js\">// Creates a new Buffer containing the UTF-8 bytes of the string &#39;buffer&#39;\nconst buf = new Buffer([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`arrayBuffer` {ArrayBuffer|SharedArrayBuffer} An [`ArrayBuffer`], [`SharedArrayBuffer`] or the `.buffer` property of a [`TypedArray`]. ",
                  "name": "arrayBuffer",
                  "type": "ArrayBuffer|SharedArrayBuffer",
                  "desc": "An [`ArrayBuffer`], [`SharedArrayBuffer`] or the `.buffer` property of a [`TypedArray`]."
                },
                {
                  "textRaw": "`byteOffset` {integer} Index of first byte to expose. **Default:** `0`. ",
                  "name": "byteOffset",
                  "type": "integer",
                  "default": "`0`",
                  "desc": "Index of first byte to expose.",
                  "optional": true
                },
                {
                  "textRaw": "`length` {integer} Number of bytes to expose. **Default:** `arrayBuffer.length - byteOffset`. ",
                  "name": "length",
                  "type": "integer",
                  "default": "`arrayBuffer.length - byteOffset`",
                  "desc": "Number of bytes to expose.",
                  "optional": true
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated: Use\n<a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a>\ninstead.</p>\n<p>This creates a view of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a> without\ncopying the underlying memory. For example, when passed a reference to the\n<code>.buffer</code> property of a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance, the newly created <code>Buffer</code> will\nshare the same allocated memory as the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>.</p>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`\nconst buf = new Buffer(arr.buffer);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 88 13 a0 0f&gt;\n\n// Changing the original Uint16Array changes the Buffer also\narr[1] = 6000;\n\nconsole.log(buf);\n// Prints: &lt;Buffer 88 13 70 17&gt;\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "arrayBuffer"
                },
                {
                  "name": "byteOffset",
                  "optional": true
                },
                {
                  "name": "length",
                  "optional": true
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated: Use\n<a href=\"#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\"><code>Buffer.from(arrayBuffer[, byteOffset[, length]])</code></a>\ninstead.</p>\n<p>This creates a view of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\"><code>ArrayBuffer</code></a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\"><code>SharedArrayBuffer</code></a> without\ncopying the underlying memory. For example, when passed a reference to the\n<code>.buffer</code> property of a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a> instance, the newly created <code>Buffer</code> will\nshare the same allocated memory as the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\"><code>TypedArray</code></a>.</p>\n<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within\nthe <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>\n<pre><code class=\"lang-js\">const arr = new Uint16Array(2);\n\narr[0] = 5000;\narr[1] = 4000;\n\n// Shares memory with `arr`\nconst buf = new Buffer(arr.buffer);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 88 13 a0 0f&gt;\n\n// Changing the original Uint16Array changes the Buffer also\narr[1] = 6000;\n\nconsole.log(buf);\n// Prints: &lt;Buffer 88 13 70 17&gt;\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`buffer` {Buffer|Uint8Array} An existing `Buffer` or [`Uint8Array`] from which to copy data. ",
                  "name": "buffer",
                  "type": "Buffer|Uint8Array",
                  "desc": "An existing `Buffer` or [`Uint8Array`] from which to copy data."
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;buffer&#39;);\nconst buf2 = new Buffer(buf1);\n\nbuf1[0] = 0x61;\n\nconsole.log(buf1.toString());\n// Prints: auffer\nconsole.log(buf2.toString());\n// Prints: buffer\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "buffer"
                }
              ],
              "desc": "<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;buffer&#39;);\nconst buf2 = new Buffer(buf1);\n\nbuf1[0] = 0x61;\n\nconsole.log(buf1.toString());\n// Prints: auffer\nconsole.log(buf2.toString());\n// Prints: buffer\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`size` {integer} The desired length of the new `Buffer`. ",
                  "name": "size",
                  "type": "integer",
                  "desc": "The desired length of the new `Buffer`."
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated: Use <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> instead (also see\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>).</p>\n<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>Prior to Node.js 8.0.0, the underlying memory for <code>Buffer</code> instances\ncreated in this way is <em>not initialized</em>. The contents of a newly created\n<code>Buffer</code> are unknown and <em>may contain sensitive data</em>. Use\n<a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size)</code></a> instead to initialize a <code>Buffer</code>\nwith zeroes.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(10);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated: Use <a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc()</code></a> instead (also see\n<a href=\"#buffer_class_method_buffer_allocunsafe_size\"><code>Buffer.allocUnsafe()</code></a>).</p>\n<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>Prior to Node.js 8.0.0, the underlying memory for <code>Buffer</code> instances\ncreated in this way is <em>not initialized</em>. The contents of a newly created\n<code>Buffer</code> are unknown and <em>may contain sensitive data</em>. Use\n<a href=\"#buffer_class_method_buffer_alloc_size_fill_encoding\"><code>Buffer.alloc(size)</code></a> instead to initialize a <code>Buffer</code>\nwith zeroes.</p>\n<pre><code class=\"lang-js\">const buf = new Buffer(10);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "textRaw": "`string` {string} String to encode. ",
                  "name": "string",
                  "type": "string",
                  "desc": "String to encode."
                },
                {
                  "textRaw": "`encoding` {string} The encoding of `string`. **Default:** `'utf8'`. ",
                  "name": "encoding",
                  "type": "string",
                  "default": "`'utf8'`",
                  "desc": "The encoding of `string`.",
                  "optional": true
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated:\nUse <a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a> instead.</p>\n<p>Creates a new <code>Buffer</code> containing <code>string</code>. The <code>encoding</code> parameter identifies\nthe character encoding of <code>string</code>.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;this is a tést&#39;);\nconst buf2 = new Buffer(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\n\nconsole.log(buf1.toString());\n// Prints: this is a tést\nconsole.log(buf2.toString());\n// Prints: this is a tést\nconsole.log(buf1.toString(&#39;ascii&#39;));\n// Prints: this is a tC)st\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "string"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ],
              "desc": "<p>Stability: 0 - Deprecated:\nUse <a href=\"#buffer_class_method_buffer_from_string_encoding\"><code>Buffer.from(string[, encoding])</code></a> instead.</p>\n<p>Creates a new <code>Buffer</code> containing <code>string</code>. The <code>encoding</code> parameter identifies\nthe character encoding of <code>string</code>.</p>\n<pre><code class=\"lang-js\">const buf1 = new Buffer(&#39;this is a tést&#39;);\nconst buf2 = new Buffer(&#39;7468697320697320612074c3a97374&#39;, &#39;hex&#39;);\n\nconsole.log(buf1.toString());\n// Prints: this is a tést\nconsole.log(buf2.toString());\n// Prints: this is a tést\nconsole.log(buf1.toString(&#39;ascii&#39;));\n// Prints: this is a tC)st\n</code></pre>\n"
            }
          ]
        },
        {
          "textRaw": "Class: SlowBuffer",
          "type": "class",
          "name": "SlowBuffer",
          "meta": {
            "deprecated": [
              "v6.0.0"
            ],
            "changes": []
          },
          "stability": 0,
          "stabilityText": "Deprecated: Use [`Buffer.allocUnsafeSlow()`] instead.",
          "desc": "<p>Returns an un-pooled <code>Buffer</code>.</p>\n<p>In order to avoid the garbage collection overhead of creating many individually\nallocated <code>Buffer</code> instances, by default allocations under 4KB are sliced from a\nsingle larger allocated object.</p>\n<p>In the case where a developer may need to retain a small chunk of memory from a\npool for an indeterminate amount of time, it may be appropriate to create an\nun-pooled <code>Buffer</code> instance using <code>SlowBuffer</code> then copy out the relevant bits.</p>\n<pre><code class=\"lang-js\">// Need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on(&#39;readable&#39;, () =&gt; {\n  const data = socket.read();\n\n  // Allocate for retained data\n  const sb = SlowBuffer(10);\n\n  // Copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n\n  store.push(sb);\n});\n</code></pre>\n<p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer\nhas observed undue memory retention in their applications.</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`size` {integer} The desired length of the new `SlowBuffer`. ",
                  "name": "size",
                  "type": "integer",
                  "desc": "The desired length of the new `SlowBuffer`."
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The\ncontents of a newly created <code>SlowBuffer</code> are unknown and may contain sensitive\ndata. Use <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> with\nzeroes.</p>\n<pre><code class=\"lang-js\">const { SlowBuffer } = require(&#39;buffer&#39;);\n\nconst buf = new SlowBuffer(5);\n\nconsole.log(buf);\n// Prints: (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;\n\nbuf.fill(0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n"
            },
            {
              "params": [
                {
                  "name": "size"
                }
              ],
              "desc": "<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>size</code> is larger than\n<a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a> or smaller than 0, <a href=\"errors.html#ERR_INVALID_OPT_VALUE\"><code>ERR_INVALID_OPT_VALUE</code></a> is\nthrown. A zero-length <code>Buffer</code> is created if <code>size</code> is 0.</p>\n<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The\ncontents of a newly created <code>SlowBuffer</code> are unknown and may contain sensitive\ndata. Use <a href=\"#buffer_buf_fill_value_offset_end_encoding\"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> with\nzeroes.</p>\n<pre><code class=\"lang-js\">const { SlowBuffer } = require(&#39;buffer&#39;);\n\nconst buf = new SlowBuffer(5);\n\nconsole.log(buf);\n// Prints: (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;\n\nbuf.fill(0);\n\nconsole.log(buf);\n// Prints: &lt;Buffer 00 00 00 00 00&gt;\n</code></pre>\n"
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "`INSPECT_MAX_BYTES` {integer} **Default:** `50` ",
          "type": "integer",
          "name": "INSPECT_MAX_BYTES",
          "meta": {
            "added": [
              "v0.5.4"
            ],
            "changes": []
          },
          "default": "`50`",
          "desc": "<p>Returns the maximum number of bytes that will be returned when\n<code>buf.inspect()</code> is called. This can be overridden by user modules. See\n<a href=\"util.html#util_util_inspect_object_options\"><code>util.inspect()</code></a> for more details on <code>buf.inspect()</code> behavior.</p>\n<p>Note that this is a property on the <code>buffer</code> module returned by\n<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>\n"
        },
        {
          "textRaw": "`kMaxLength` {integer} The largest size allowed for a single `Buffer` instance. ",
          "type": "integer",
          "name": "kMaxLength",
          "meta": {
            "added": [
              "v3.0.0"
            ],
            "changes": []
          },
          "desc": "<p>An alias for <a href=\"#buffer_buffer_constants_max_length\"><code>buffer.constants.MAX_LENGTH</code></a>.</p>\n<p>Note that this is a property on the <code>buffer</code> module returned by\n<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>\n",
          "shortDesc": "The largest size allowed for a single `Buffer` instance."
        }
      ],
      "methods": [
        {
          "textRaw": "buffer.transcode(source, fromEnc, toEnc)",
          "type": "method",
          "name": "transcode",
          "meta": {
            "added": [
              "v7.1.0"
            ],
            "changes": [
              {
                "version": "v8.0.0",
                "pr-url": "https://github.com/nodejs/node/pull/10236",
                "description": "The `source` parameter can now be a `Uint8Array`."
              }
            ]
          },
          "signatures": [
            {
              "params": [
                {
                  "textRaw": "`source` {Buffer|Uint8Array} A `Buffer` or `Uint8Array` instance. ",
                  "name": "source",
                  "type": "Buffer|Uint8Array",
                  "desc": "A `Buffer` or `Uint8Array` instance."
                },
                {
                  "textRaw": "`fromEnc` {string} The current encoding. ",
                  "name": "fromEnc",
                  "type": "string",
                  "desc": "The current encoding."
                },
                {
                  "textRaw": "`toEnc` {string} To target encoding. ",
                  "name": "toEnc",
                  "type": "string",
                  "desc": "To target encoding."
                }
              ]
            },
            {
              "params": [
                {
                  "name": "source"
                },
                {
                  "name": "fromEnc"
                },
                {
                  "name": "toEnc"
                }
              ]
            }
          ],
          "desc": "<p>Re-encodes the given <code>Buffer</code> or <code>Uint8Array</code> instance from one character\nencoding to another. Returns a new <code>Buffer</code> instance.</p>\n<p>Throws if the <code>fromEnc</code> or <code>toEnc</code> specify invalid character encodings or if\nconversion from <code>fromEnc</code> to <code>toEnc</code> is not permitted.</p>\n<p>The transcoding process will use substitution characters if a given byte\nsequence cannot be adequately represented in the target encoding. For instance:</p>\n<pre><code class=\"lang-js\">const buffer = require(&#39;buffer&#39;);\n\nconst newBuf = buffer.transcode(Buffer.from(&#39;€&#39;), &#39;utf8&#39;, &#39;ascii&#39;);\nconsole.log(newBuf.toString(&#39;ascii&#39;));\n// Prints: &#39;?&#39;\n</code></pre>\n<p>Because the Euro (<code>€</code>) sign is not representable in US-ASCII, it is replaced\nwith <code>?</code> in the transcoded <code>Buffer</code>.</p>\n<p>Note that this is a property on the <code>buffer</code> module returned by\n<code>require(&#39;buffer&#39;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>\n"
        }
      ],
      "type": "module",
      "displayName": "Buffer"
    }
  ]
}
