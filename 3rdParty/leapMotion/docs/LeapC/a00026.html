<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Leap Motion C API: Images</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="leapmotion-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Leap Motion C API
   &#160;<span id="projectnumber">3.1</span>
   </div>
   <div id="projectbrief">The API to the LeapC library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>LeapC</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li class="current"><a href="pages.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00026.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Images </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#requestimage">Requesting Images</a><ul><li class="level2"><a href="#imagebuffersize">Determining the Image Buffer Size</a></li>
</ul>
</li>
<li class="level1"><a href="#imagedistortion">Image Distortion</a><ul><li class="level2"><a href="#rectifypoints">Rectifying Image Points</a></li>
<li class="level2"><a href="#rectifywithshader">Rectifying with a Shader</a></li>
<li class="level2"><a href="#distortionchanges">Detecting when the Distortion Map Changes</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The Leap Motion controller uses infrared stereo cameras as tracking sensors. The LeapC API provides an image buffer containing the sensor brightness values and a distortion buffer containing the camera calibration map. The distortion map can be used to correct lens distortion in the image data. The function <a class="el" href="a00036.html#ga0f8c7bb9c7d46fed78efe183244f9812" title="Provides the point in the image corresponding to a ray projecting from the camera. ">LeapRectilinearToPixel()</a> can be used to undistort specific pixels in an image and the function <a class="el" href="a00036.html#gacc6a5c80f87a60c63889407a45a3344b" title="Provides the corrected camera ray intercepting the specified point on the image. ">LeapPixelToRectilinear()</a> can be used to find the 3D location corresponding to a matched pair of stereo pixels.</p>
<h1><a class="anchor" id="requestimage"></a>
Requesting Images</h1>
<p>Images are not sent automatically. For each desired stereo image pair, you must call LeapRequestImage(), identifying the associated tracking frame and supplying a buffer large enough to hold both stereo images. You must request a set of images within a few frames of the corresponding tracking frame, otherwise the image data will have already been discarded.</p>
<p>When the image is available, it is written to the supplied buffer. Once the buffer is completely written, a <a class="el" href="a00029.html#a00058" title="The properties of a requested Image. ">LEAP_IMAGE_COMPLETE_EVENT</a> is added to the event queue and can be accessed via <a class="el" href="a00036.html#ga2a8aecad339f0fd339ca22a3e7b389f6" title="Polls the connection for a new event. ">LeapPollConnection()</a>. The image complete event contains image properties, distortion correction data, and a pointer to the buffer.</p>
<p>Both images from the stereo cameras are written to the same buffer; left image first and then the right image.</p>
<p>To get an image:</p>
<ol type="1">
<li>Open the connection.</li>
<li>Poll for tracking frames.</li>
<li>Allocate a buffer large enough to hold both pairs of the stereo image.</li>
<li>Create a <a class="el" href="a00029.html#a00059" title="Describes the image to request. ">LEAP_IMAGE_FRAME_DESCRIPTION</a> struct.</li>
<li>Set the struct fields to identify the desired image frame and type and specify your image buffer.</li>
<li>Create a <a class="el" href="a00029.html#a00061" title="Opaque struct that identifies an image request. ">LEAP_IMAGE_FRAME_REQUEST_TOKEN</a> struct.</li>
<li>Call <a class="el" href="a00036.html#gaf157e7c0438fec45851069189735e672" title="Requests an image from the service. ">LeapRequestImages()</a>, passing in the connection handle, the description struct and the token struct.</li>
<li>Save the token struct. If you need to deallocate your image buffer before the request is complete, you must call <a class="el" href="a00036.html#gada00b4a763b3d43f88b78e9c8f8afe9c" title="Cancels a images request identified by the token returned by a prior call to LeapRequestImages();. ">LeapCancelImageFrameRequest()</a> with the token first. Otherwise, LeapC could write to the deallocated memory area. The token also correlates the image complete message with the original request.</li>
<li>Continue polling for tracking frames and status messages. When the image request is complete and the buffer has been written, a <a class="el" href="a00029.html#a00058" title="The properties of a requested Image. ">LEAP_IMAGE_COMPLETE_EVENT</a> message is provided by <a class="el" href="a00036.html#ga2a8aecad339f0fd339ca22a3e7b389f6" title="Polls the connection for a new event. ">LeapPollConnection()</a>. The <a class="el" href="a00029.html#a00058" title="The properties of a requested Image. ">LEAP_IMAGE_COMPLETE_EVENT</a> struct contains the image token, a description of the image, and the distortion map.</li>
<li>After the image is complete, you can release or reuse the image buffer when desired.</li>
</ol>
<p>The following example illustrates how to call the <a class="el" href="a00036.html#gaf157e7c0438fec45851069189735e672" title="Requests an image from the service. ">LeapRequestImages()</a> function:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;LEAP_IMAGE_FRAME_DESCRIPTION frameDescription;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;frameDescription.type = eLeapImageType_Default;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;frameDescription.frame_id = frame-&gt;info.frame_id; //frame is LEAP_TRACKING_EVENT struct</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;frameDescription.buffer_len = image_size; //the size of image_buffer</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;frameDescription.pBuffer = image_buffer; //typically allocated in advance based on known image size</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;image_token = malloc(sizeof(LEAP_IMAGE_FRAME_REQUEST_TOKEN));</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;eLeapRS result = LeapRequestImages(*connection, &amp;frameDescription, image_token);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;if(result != eLeapRS_Success)</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  printf(&quot;LeapRequestImages call was %s.\n&quot;, ResultString(result));</div>
</div><!-- fragment --><p>If the image buffer is too small, the image request will fail. Instead of an image complete event, you will get an image request error event. This error event will contain the required buffer size, which you can use to re-allocate your buffer for subsequent image requests.</p>
<h2><a class="anchor" id="imagebuffersize"></a>
Determining the Image Buffer Size</h2>
<p>The required image buffer size depends on the device type as well as the image type and format. The buffer size depends on the width, height, and pixel format (bytes per pixel) of the image. A single buffer must hold stereo images. For example, if the current images produced by a Leap Motion device is 640x240, 1-byte pixels, then the buffer size must be: 640 x 240 x 1 x 2 = 307,200 bytes. However, since the resolution can change dynamically, your code should be capable of resizing the image buffer as needed.</p>
<p>If your image request supplies a buffer that is too small for the current image, LeapC provides an error message via <a class="el" href="a00036.html#ga2a8aecad339f0fd339ca22a3e7b389f6" title="Polls the connection for a new event. ">LeapPollConnection()</a>. The <a class="el" href="a00029.html#a00060" title="The error struct received from LeapPollConnection() when an image request goes wrong. ">LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT</a> struct contains the required buffer size for the requested image type and format. You can use the required_buffer_len field to reallocate the buffer for future image requests. (The image request that contained the insufficient buffer is not fulfilled &ndash; you would need to re-issue the request with an updated buffer to get that particular image. For most purposes, though, it is acceptable to skip a failed request and just continue on with the next frame's image.)</p>
<p>The following example code resizes the byte array used to hold the image data based on the required_buffer_len field of an <a class="el" href="a00029.html#a00060" title="The error struct received from LeapPollConnection() when an image request goes wrong. ">LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT</a> struct:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;//imageErrorEvent is a LEAP_IMAGE_FRAME_REQUEST_ERROR_EVENT struct</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;//Resize image buffer if too small</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;if(image_size &lt; imageErrorEvent-&gt;required_buffer_len){</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  image_size = imageErrorEvent-&gt;required_buffer_len;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  if(image_buffer) free(image_buffer); //image_buffer is an array of byte</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  image_buffer = malloc((size_t)image_size);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  printf(&quot;Resized image buffer to %lli.\n&quot;, (long long int)image_size);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;if(imageErrorEvent-&gt;error == eLeapImageRequestError_ImagesDisabled)</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  printf(&quot;Warning: Images disabled. Check your control panel settings.&quot;);</div>
</div><!-- fragment --><h1><a class="anchor" id="imagedistortion"></a>
Image Distortion</h1>
<p>When a ray of light enters one of the Leap Motion cameras, the lens bends the ray so that it hits the sensor, which records it as a greyscale brightness value at a specific pixel location. Of course, no lens is perfect, so a ray of light does not land on the sensor in the optically perfect spot. The distortion map provides data to correct this imperfection, allowing you to calculate the true angle of the original ray of light. You can use the corrected angle to generate a rectified image, and, using the angles from both images in the stereo pair, you can triangulate the 3D location of a feature identified in both images.</p>
<p>For image rectification, the distortion map can be fed to a shader program that can efficiently interpolate the correction applied to rays of light to produce a texture containing the rectified image. For getting the true angle for a small set of points, you can use the <a class="el" href="a00036.html#gacc6a5c80f87a60c63889407a45a3344b" title="Provides the corrected camera ray intercepting the specified point on the image. ">LeapPixelToRectilinear()</a> function (but this is not typically efficient enough to transform a full bitmap at a high frame rate).</p>
<h2><a class="anchor" id="rectifypoints"></a>
Rectifying Image Points</h2>
<p>To rectify individual points in an image, you can call the <a class="el" href="a00036.html#ga0f8c7bb9c7d46fed78efe183244f9812" title="Provides the point in the image corresponding to a ray projecting from the camera. ">LeapRectilinearToPixel()</a> function. Given a ray from the camera, this function returns the pixel coordinates in the image buffer that contain the light recorded from that direction, corrected for lens distortion.</p>
<p>The following code takes a target texture size and determines the correct pixel brightness value. For each pixel, the code computes the ray direction to the point in the scene that would illuminate the target pixel given an ideal optical system. The code then corrects for optical distortion by calling <a class="el" href="a00036.html#ga0f8c7bb9c7d46fed78efe183244f9812" title="Provides the point in the image corresponding to a ray projecting from the camera. ">LeapRectilinearToPixel()</a>, which provides the pixel coordinates in the image buffer that actually contains the brightness value for the target pixel. The code copies the brightness value to the target texture buffer. The result is a rectified image.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;//The pixel size of the textures we write the undistorted images to</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define TEX_WIDTH 400</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#define TEX_HEIGHT 400</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;//Max field of view varies by device, use 8 for the peripheral, 22 for Rigel</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;#define MAX_FOV 22</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;//image_buffer contains the image data</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;for( float row = 0; row &lt; TEX_HEIGHT; row++ ) {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  for( float col = 0; col &lt; TEX_WIDTH; col++ ) {</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    //Normalize from pixel xy to range [0..1]</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    LEAP_VECTOR input;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    input.x = col/TEX_WIDTH;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    input.y = row/TEX_HEIGHT;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    //Convert from normalized [0..1] to ray slopes</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    input.x = (input.x - .5) * MAX_FOV;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    input.y = (input.y - .5) * MAX_FOV;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    LEAP_VECTOR pixel = LeapRectilinearToPixel(*connection, eLeapPerspectiveType_stereo_left, input);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    int dindex = (int)floor(row * TEX_WIDTH + col);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    int pindex = (int)roundf(pixel.y) * image_width + (int)roundf(pixel.x);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    if(pixel.x &gt;= 0 &amp;&amp; pixel.x &lt; image_width &amp;&amp; pixel.y &gt;=0 &amp;&amp; pixel.y &lt; image_height){</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;      undistorted_image_left[dindex] = ((char*)image_buffer)[pindex];</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    } else {</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;      undistorted_image_left[dindex] = 128;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    }</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  }</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div>
</div><!-- fragment --><p>For the right image, remember to offset the index into the image_buffer array since the right image follows the left.</p>
<p>You can get the actual device field of view from the <a class="el" href="a00029.html#a00051" title="Properties of a Leap device. ">LEAP_DEVICE_INFO</a> struct. Use tan(fov/2) in the calculation above instead of MAX_FOV.</p>
<p>Note that <a class="el" href="a00036.html#ga0f8c7bb9c7d46fed78efe183244f9812" title="Provides the point in the image corresponding to a ray projecting from the camera. ">LeapRectilinearToPixel()</a> may not be fast enough to rectify the image to a high resolution texture in real-time. Generally you should limit its use to individual points, image patches, or low-resolution textures. For better performance for full images, you can use a shader to rectify the image.</p>
<p>See <a class="el" href="a00020.html">Rectifying Points Example</a></p>
<h2><a class="anchor" id="rectifywithshader"></a>
Rectifying with a Shader</h2>
<p>To rectify an entire image with a shader, create a texture containing the data in the distortion buffer. The distortion buffer is contained in the distortion_matrix field of the <a class="el" href="a00029.html#a00058" title="The properties of a requested Image. ">LEAP_IMAGE_COMPLETE_EVENT</a> struct. This data is set up to use a shader's normal uv interpolation mechanism. You can use the interpolated uv coordinates to look up the corrected brightness in the image texture, as in the following fragment shader program:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;uniform sampler2D rawTexture;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;uniform sampler2D distortionTexture;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;void main()</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  vec2 distortionIndex = texture2D(distortionTexture, gl_TexCoord[0].st).xy;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  float hIndex = distortionIndex.r;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  float vIndex = distortionIndex.g;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  if(vIndex &gt; 0.0 &amp;&amp; vIndex &lt; 1.0 &amp;&amp; hIndex &gt; 0.0 &amp;&amp; hIndex &lt; 1.0)</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    gl_FragColor = vec4(texture2D(rawTexture, distortionIndex).rrr, 1.0);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  }</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  else</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  {</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    gl_FragColor = vec4(0.2, 0.0, 0.0, 1.0);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  }</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;}</div>
</div><!-- fragment --><p>To interpolate correctly, the distortion texture must use the following filter and wrap parameters:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</div>
</div><!-- fragment --><p>The distortion texture itself must use two floating point values per texel and contain 64x64 texels:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;glTexImage2D(GL_TEXTURE_2D, 0, GL_RG, 64, 64, 0, GL_RG, GL_FLOAT, distortion_buffer_left);</div>
</div><!-- fragment --><p>The distortion map itself rarely changes &ndash; the only time it changes is if the Leap Motion hardware is swapped with a different device or if the device is rotated so that the user's hands enter from the opposite side of the vertical field of view. In this case the Leap Motion software inverts the image, and the distortion map, to automatically maintain the proper orientation. (Auto-orientation can be turned off in the Leap Motion service configuration.)</p>
<p>See <a class="el" href="a00022.html">Rectifying with a Shader Example</a></p>
<h2><a class="anchor" id="distortionchanges"></a>
Detecting when the Distortion Map Changes</h2>
<p>The distortion map contains a grid of values that can be used to rectify the images. Rectification should be performed if you are aligning 3D objects with pixels in the images or if you are performing stereo triangulation on the image pair.</p>
<p>Each image complete event contains the distortion map for that image, however, since translating the map to an interpolation array or shader texture can itself be an expensive task, you typically only want to do this when the distortion map actually changes &ndash; not once for every image request. The distortion map can only change when the images are flipped due to automatic or manual re-orientation or if the device itself is changed. (For internal reasons) there is no way to tell that a reorientation has occured. However, you can use the <a class="el" href="a00029.html#ab7d70553fe4251220f4ccc95cbc6da48" title="A version number for the distortion matrix. ">LEAP_IMAGE_COMPLETE_EVENT::matrix_version</a> field to detect when the distortion map changes. When the matrix_version changes between images, you know that the distortion map has changed. The matrix version number ALWAYS increases when the distortion map changes and never returns to a prior value.</p>
<p>See <a class="el" href="a00022.html">Rectifying with a Shader Example</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">LeapC</a></li>
    <li class="footer">Generated on Tue Dec 13 2016 15:48:45 for Leap Motion C API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
