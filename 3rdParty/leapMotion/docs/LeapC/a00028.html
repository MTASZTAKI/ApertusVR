<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Leap Motion C API: Setting Up Virtual and Augmented Reality Scenes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="leapmotion-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Leap Motion C API
   &#160;<span id="projectnumber">3.1</span>
   </div>
   <div id="projectbrief">The API to the LeapC library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>LeapC</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li class="current"><a href="pages.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00028.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Setting Up Virtual and Augmented Reality Scenes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Setting up a 3D scene to display hands controlled by the Leap Motion device in the different available Virtual Reality (VR) APIs involves similar steps &ndash; though there are differences in how much an API or engine does for you. In general, these steps include:</p>
<ul>
<li>Mounting the Leap Motion device on the HMD, if using the peripheral device.</li>
<li>Calculating the transforms that describe the difference in position and orientation between mounting the Leap Motion device on the HMD and placing it on a table.</li>
<li>Accessing the Leap Motion API to get tracking data.</li>
<li>Calculating the transforms necessary to convert from the Leap Motion right-handed coordinate system to your target coordinate system (if the coordinate systems are different).</li>
<li>Translating coordinates for positions, directions, and orientations from the Leap Motion coordinate system into the target world coordinate system.</li>
<li>For Augmented Reality (AR), rendering the Leap Motion sensor images.</li>
</ul>
<h1><a class="anchor" id="vrmount"></a>
Mounting the Leap Motion Device</h1>
<p>To use the older Leap Motion peripheral in a VR context, you must first devicse a way to mount it to your HMD.</p>
<div class="image">
<img src="Leap_VR_Mount.png" alt="Leap_VR_Mount.png"/>
</div>
<p>For the resourceful, there are no end of ways to attach the Leap Motion sensor to a head-mounted display: double-sided tape, velcro, rubber bands. For the rest of us, Leap Motion sells a <a href="http://store-us.leapmotion.com/products/universal-vr-mount-pre-order">custom mount</a>. The 3D printer files are also available (free) if you prefer to print your own. You can download the files from <a href="http://www.thingiverse.com/thing:445866">Thingivers</a> and <a href="https://grabcad.com/library/leap-motion-vr-developer-mount-1">Grabcad</a>. The Leap Motion mount was designed with the Oculus Rift DK1 and DK2 in mind, but since it uses double-sided tape, it could work with other HMD's as well &ndash; as long as they have a fairly flat, Leap-sized area in the front middle.</p>
<p><b>Note:</b> We recommend that you mount the Leap Motion device with the green power indicator LED facing downward. While the Leap Motion software will flip the coordinate system and images if mounted indicator upwards, it can only do so after a hand enters the view. In the meantime (or if auto-orientation is turned off in the Control Panel), the images from the cameras can appear upside down.</p>
<h1><a class="anchor" id="vr_offset"></a>
Interpupillary Offset</h1>
<p>Whether you mount a peripheral device on an HMD or use a HMD with an embedded device, you measure the offsets between the Leap Motion origin and the midpoint of the line running from pupil to pupil in all dimensions (this line is refered to as the interpupillary line). These measurements will be required to correctly place 3D hands in the scene. The device should be mounted square to the device so that the cameras are facing straight ahead and level to the horizon when you are looking straight ahead and level.</p>
<div class="image">
<img src="HMD_Mounting.png" alt="HMD_Mounting.png"/>
</div>
<p>The matrix that represents the offset of the Leap Motion device from the user's interpupillary and medial lines looks like the following, where \(t_{x}\), \(t_{y}\), and \(t_{z}\) are your measured offsets:</p>
<p class="formulaDsp">
\[ T_{mounted} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; 0 &amp; t_y \\ 0 &amp; 0 &amp; 1 &amp; t_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \]
</p>
<p>Typical values for the translation components on an Oculus Rift are \(t_{x} = 0\), \(t_{y} = 0\), and \(t_{z} = -80\). When mounting your device, strive to keep \(t_{x}\), \(t_{y}\) as close to zero as possible.</p>
<p>If your Leap Motion device is mounted square to the HMD with the y-axis projecting forward, you can specify the rotation of the device from upward-facing desktop mode to the forward-facing HMD mode with this matrix, which represents a -90 degree rotation around the x-axis and a 180 degree rotation around the z-axis:</p>
<p class="formulaDsp">
\[ R_{mounted} = \begin{bmatrix} -1 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp;-1 &amp; 1 \\ 0 &amp;-1 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \]
</p>
<p>Combine the two matrices into one transform by multiplication:</p>
<p class="formulaDsp">
\[ M_{tabletop{\mapsto}mounted} = T_{mounted} \times R_{mounted} \]
</p>
<h2><a class="anchor" id="vr_proxy"></a>
Using a Proxy Object</h2>
<p>An alternate method of achieving this goal is to place a proxy object representing the Leap Motion device at the same relative position and orientation to the virtual world cameras as the device has to your eyes in the real world. This method is easier to use in graphic development environments like Unity and Unreal. The VR assets in the Leap Motion Unity asset package take this approach.</p>
<div class="image">
<img src="VR_rig.png" alt="VR_rig.png"/>
</div>
<p>A proxy object for the Leap Motion device placed in relationship to the left- and right-eye cameras.</p>
<p>You can then transform the Leap Motion coordinates using the model matrix of the proxy object.</p>
<p>Note that this doesn't account for coordinate system and unit conversions, which we will discuss later.</p>
<h2><a class="anchor" id="vr_angled_mount"></a>
Angling the Mount</h2>
<p>If you angle your mount relative to the HMD, you must measure the angles and apply the same rotations to the tracking data. Angling the Leap Motion device downward can provide a more comfortable working space, but this also causes visual disorientation when using the video passthrough from the device cameras. Thus, an angled mount could restrict the types of applications you can develop or use.</p>
<p>You can represent mount rotations as the following matrices, where \(\alpha\), \(\beta\), \(\gamma\) are your angles measured counterclockwise (right-hand rule) around the x, y, and z axes:</p>
<p class="formulaDsp">
\[ R_x = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; cos(\alpha) &amp;-sin(\alpha) &amp; 1 \\ 0 &amp; sin(\alpha) &amp; cos(\alpha) &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \; R_y = \begin{bmatrix} cos(\beta) &amp; 0 &amp; sin(\beta) &amp; 1 \\ 0 &amp; 1 &amp; 0 &amp; 1 \\ -sin(\beta) &amp; 0 &amp; cos(\beta) &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \; R_z = \begin{bmatrix} cos(\gamma) &amp; -sin(\gamma) &amp; 0 &amp; 1 \\ sin(\gamma) &amp; cos(\gamma) &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \]
</p>
<p>Combine the rotations by multiplying these matrices:</p>
<p class="formulaDsp">
\[ R_{mounted} = R_{x} \times R_{y} \times R_{z} \]
</p>
<p>Finally, you can combine the translations for the mount offset and rotations for the mount angles into one transform by multiplying the matrices:</p>
<p class="formulaDsp">
\[ M_{tabletop{\mapsto}mounted} = T_{mounted} \times R_{mounted} \]
</p>
<h1><a class="anchor" id="vr_coordinates"></a>
Converting Coordinate Systems</h1>
<p>The Leap Motion coordinate system uses a right-handed convention and units of millimeters. Positive y is up; z is front-to-back; x is right-to-left. Your world might use a different set of conventions and units. For example, Unity3D uses a left-handed convention and units of meters, but also oriented with positive y facing up. Unreal Engine uses a left-handed convention and units of centimeters, and with positive z facing up. Three.js, a popular WebGL library uses the same conventions as the Leap Motion, but has no intrinsic convention for units. </p><pre class="fragment">*Note:* the scripts in the Unity asset package and the Unreal Engine plugin transform the coordinate systems automatically.
</pre><p>Scaling from Leap Motion coordinates to a unit system in meters can be achieved with the following matrix (change the scale factor from .001 to the correct value to scale to different linear units):</p>
<p class="formulaDsp">
\[ S_{mm{\mapsto}m} = \begin{bmatrix} 0.001 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0.001 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0.001 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \]
</p>
<p>Note that the scale factors used assume that your game is using a 1:1 scale with reality. This is the default for Unity3D and Unreal Engine, for example, the standard Unity character controller prefabs are human scale (between 1 and 2 meters tall). Matching the scale accurately is important in a VR scene since the user has a much better sense of where their virtual hands should be in comparison to their real hands. In an AR scene, this can be even more critical.</p>
<p>Changing the basis of the coordinate system can also be accomplished with a matrix transform. For example, the following matrix changes Leap coordinates and directions to the Unity left-handed convention (by scaling the z-axis by -1):</p>
<p class="formulaDsp">
\[ S_{RH{\mapsto}LH} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \]
</p>
<h1><a class="anchor" id="vr_head_motion"></a>
Head Motion</h1>
<p>In addition to the physical offset of the device from the user's eyes, you must compensate for the motion of the user's head while the scene is playing. Otherwise, the hands will appear to move when the head moves. Head tracking information can be accessed from the Head tracking APIs of your HMD or VR SDK. You want to anchor the Leap tracking data to the midpoint of the interpupillary line &ndash; the line between the two cameras in the virtual world. Typically, the head tracking information will be in the form of another transform matrix. For example, in the Oculus API, you can get the head tracking data relative to this point using <a href="https://developer3.oculus.com/doc/1.9-libovr/structovr_tracking_state.html">GetTrackingState().HeadPose</a>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ovrPosef headPose = ovr_GetTrackingState(...).HeadPose.ThePose;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;OVR::Matrix4f translation = OVR::Matrix4f::Translation(headPose.Position);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;OVR::Matrix4f rotation = OVR::Matrix4f(headPose.Orientation);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;OVR::Matrix4f hmdToWorld = translation * rotation;</div>
</div><!-- fragment --><p>If you are using a proxy object which is parented to a scene object that is already driven by the HMD head tracking, then this step has already been done.</p>
<h1><a class="anchor" id="vr_tracking_data"></a>
Accessing Tracking Data</h1>
<p>Accessing the basic tracking data from the Leap Motion service is no different in a VR app than any other. Do note that when the Leap Motion sensor is mounted on an HMD, you should set the eLeapPolicyFlag_OptimizeHMD policy. This policy essentially instructs the Leap Motion software to expect hands to enter the field of view with their backs toward the cameras rather than their palms.</p>
<h1><a class="anchor" id="vr_transforms"></a>
Transforming Tracking Data</h1>
<p>Finally, once the Leap Motion hardware is mounted and measured, the scene is setup and basic design decisions made, you can transform the Leap Tracking data into the scene so hands (or interaction if not actually showing hands) appear in the correct place. Essentially, you take all the matrices defined above that are relevant to your graphics system, multiply them together and use the result to transform the Leap Motion tracking data. Obviously, you want to precompute as much of this transformation as possible since most of the matrices do not change from frame to frame.</p>
<p class="formulaDsp">
\[ M_{Leap{\mapsto}World} = M_{HMD{\mapsto}World} \times S_{unit conversion} \times S_{axis conversion} \times M_{tabletop{\mapsto}mounted} \]
</p>
<p>For example, if your Leap device is mounted on an Oculus Rift DK2 without any odd angles and your world model uses a left-handed coordinate convention and units of meters, then you can take \(M_{tabletop{\mapsto}mounted}\) as defined above, with \(t_x = t_y = 0\) and \(t_z = -80\) and multiply it by the coordinate unit (mm to m) and basis change (right-handed to left-handed) matrices, and finally by the HMD transform:</p>
<p class="formulaDsp">
\[ \begin{equation} M_{Leap{\mapsto}World} = M_{HMD{\mapsto}World} \times \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \times \begin{bmatrix} 0.001 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0.001 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0.001 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \times \begin{bmatrix} -1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp;-1 &amp; 0 \\ 0 &amp;-1 &amp; 0 &amp; -80 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \end{equation} \]
</p>
<h2><a class="anchor" id="vr_transforms_position"></a>
Transform a Position</h2>
<p>To transform a position in Leap Motion coordinates to world coordinates you essentially multiply the coordinate vector by the \(M_{Leap{\mapsto}World}\) matrix.</p>
<h2><a class="anchor" id="vr_transforms_direction"></a>
Transform a Direction</h2>
<p>Transforming a direction vector is very similar to transforming a position, except that you do not want to apply the coordinate scaling used to change the linear unit of measurement.</p>
<p><b>Note:</b> If you are converting units, you must create a different transform that does not include the unit scaling matrix:</p>
<p class="formulaDsp">
\[ \begin{equation} M_{Leap{\mapsto}World} = M_{HMD{\mapsto}World} \times S_{axis conversion} \times M_{tabletop{\mapsto}mounted} \end{equation} \]
</p>
<h1><a class="anchor" id="ar_camera"></a>
Camera Placement in an AR scene</h1>
<p>For a VR scene (without camera images), proper placement of the cameras is straightforward: each camera should be at the user's corresponding eyepoint.</p>
<p>For an AR scene (using camera images), proper placement is a judgement call. Images from the Leap Motion cameras are 2D representations taken from a particular point of view and, unlike 3D data, you cannot simply apply a transformation to change the view to a different vantage point. In order to make the camera images match the 3D tracking data, you must move the cameras forward by the same amount that the physical Leap device is forward of the user's eyes (i.e. 8cm for the Oculus). If using the older Leap Motion peripheral device, you must also move them closer together, since the peripheral cameras are 40mm apart, while the typical distance between human pupils is 64mm. However, moving the cameras closer together changes the stereo disparity and will make objects appear to be larger then they are in real life.</p>
<p>You can put the scene cameras at the user's pupils to maximize 3D accuracy or you can move them forward and closer to maximize alignment between the images and the 3D objects. You can also compromise and place the cameras between these two extremes. It really depends on which aspect is more important to your content.</p>
<div class="image">
<img src="VR_Oculus_Leap.png" alt="VR_Oculus_Leap.png"/>
</div>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">LeapC</a></li>
    <li class="footer">Generated on Tue Dec 13 2016 15:48:45 for Leap Motion C API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
