


  
  
 
  
  
 


<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Camera Images &mdash; Leap Motion Python SDK v3.1 documentation</title>
    
    <link rel="stylesheet" href="../../cpp/_static/bootstrap-3.0.0/css/documentation-bundle.1471552333.css" type="text/css" />
    
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
      <script type="text/javascript" src="../../cpp/_static/bootstrap-3.0.0/js/documentation-bundle.1471552333.js"></script>
    <link rel="top" title="Leap Motion Python SDK v3.1 documentation" href="../index.html" />
    <link rel="up" title="Using the Tracking API" href="Leap_Guides2.html" />
    <link rel="next" title="Serializing Tracking Data" href="Leap_Serialization.html" />
    <link rel="prev" title="Coordinate Systems" href="Leap_Coordinate_Mapping.html" />
<script type="text/javascript" src="/assets/standalone-header.js?r9"></script>
<link rel="stylesheet" href="/assets/standalone-header.css?r9" type="text/css" />

<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31536531-1']);
  _gaq.push(['_setDomainName', 'leapmotion.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

 

<script>

    function getQueryValue(variable)
    {
        var query = window.location.search.substring(1);
        var vars = query.split("&");
        for (var i=0;i<vars.length;i++) {
            var pair = vars[i].split("=");
            if(pair[0] == variable){return pair[1];}
        }
        return(false);
    }
        var relPath = "../../";

    var requestedAPI = getQueryValue("proglang");
    if(requestedAPI == "current") requestedAPI = localStorage["currentAPI"];
    var pageAPI = 'python';
    var hasAPI = {};
    hasAPI.cpp = true;
    hasAPI.objc = true;
    hasAPI.java = true;
    hasAPI.javascript = true;
    hasAPI.python = true;

    if(requestedAPI && (requestedAPI != pageAPI))
    {
        if(pageAPI != 'none'){
            var redirectedLocation = relPath + 'python/devguide/Leap_Images.html';
            if( requestedAPI == 'cpp' && hasAPI.cpp){
                redirectedLocation = relPath + "cpp/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'csharp' && hasAPI.csharp){
                redirectedLocation = relPath + "csharp/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'unity' && hasAPI.unity){
                redirectedLocation = relPath + "unity/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'objc' && hasAPI.objc){
                redirectedLocation = relPath + "objc/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'java' && hasAPI.java) {
                redirectedLocation = relPath + "java/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'javascript' && hasAPI.javascript){
                redirectedLocation = relPath + "javascript/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'python' && hasAPI.python){
                redirectedLocation = relPath + "python/devguide/Leap_Images.html";
            }
            else if( requestedAPI == 'unreal' && hasAPI.unreal) {
                redirectedLocation = relPath + "unreal/devguide/Leap_Images.html";
            } else {
                    redirectedLocation ="Leap_Guides2.html";
            }

            //Guard against redirecting to the same page (infinitely)
            if(relPath + 'python/devguide/Leap_Images.html' != redirectedLocation) window.location.replace(redirectedLocation);
        }
    }

</script>

<script>
window.addEventListener('keyup', handleKeyInput);
function handleKeyInput(e)
{
    var code;
    if (!e) var e = window.event;
    if (e.keyCode) code = e.keyCode;
    else if (e.which) code = e.which;
    var character = String.fromCharCode(code);
    if( character == "J" & e.altKey){
            window.location.assign("Leap_Coordinate_Mapping.html");    }
    else if( character == "K" & e.altKey){
            window.location.assign("Leap_Serialization.html");
    }

}
</script>


  </head>
  <body role="document">

<div class="developer-portal-styles">
  <header class="navbar navbar-static-top developer-navbar header beta-header">
    <nav class="container pr">
      <a class="logo-link pull-left" href="/">
        <img alt="Leap Motion Developers" class="media-object pull-left white-background" src="../_static/logo.png" />
      </a>
      <span class="inline-block hidden-phone developer-logo-text">
        <div class="text">
          <a href="/">
            <span class="more-than-1199">Developer Portal</span>

          </a>
        </div>
      </span>

      <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <!-- Everything within here will be hidden at 940px or less, accessible via a button. -->
      <div class="nav-collapse">
        <ul class="nav header-navigation developer-links">
          <li class="external-link"><a href="https://developer.leapmotion.com/features">What's new</a> </li>
          <li class="external-link"><a href="https://developer.leapmotion.com/downloads/skeletal-beta" class="">Getting Started</a></li>
          <li><a class="active" href="#" class="">Documentation</a></li>
          <li class="external-link"> <a href="https://developer.leapmotion.com/gallery" class="">Examples</a> </li>
          <li class="external-link"> <a href="https://www.leapmotion.com/blog/category/labs/" class="" target="_blank">Blog <i class='fa fa-external-link'></i></a> </li>
          <li class="external-link"> <a href="https://community.leapmotion.com/category/beta" class="" target="_blank">Community <i class='fa fa-external-link'></i></a> </li>
        </ul>
      </div>

    </nav>
  </header>
</div>
<section class="main-wrap">
  <div data-swiftype-index="true">
    <div class="second_navigation">
      <div class="container">
        <div class="row">
          <div class="col-md-8">
            
              

<ul>
  <li>
      <a href="../../javascript/devguide/Leap_Images.html?proglang=javascript" onclick="localStorage['currentAPI'] = 'javascript'">JavaScript</a>
    
  </li>
  <li>
      <a href="Leap_Guides2.html?proglang=current" onclick="localStorage['currentAPI'] = 'unity'">Unity</a>
    
  </li>
  <li>
      <a href="Leap_Guides2.html?proglang=current" onclick="localStorage['currentAPI'] = 'csharp'">C#</a>
    
  </li>
  <li>
      <a href="../../cpp/devguide/Leap_Images.html?proglang=cpp" onclick="localStorage['currentAPI'] = 'cpp'">C++</a>
    
  </li>
  <li>
      <a href="../../java/devguide/Leap_Images.html?proglang=java" onclick="localStorage['currentAPI'] = 'java'">Java</a>
    
  </li>
  <li>
      Python
    
  </li>
  <li>
      <a href="../../objc/devguide/Leap_Images.html?proglang=objc" onclick="localStorage['currentAPI'] = 'objc'">Objective-C</a>
    
  </li>
  <li>
      <a href="Leap_Guides2.html?proglang=current" onclick="localStorage['currentAPI'] = 'unreal'">Unreal</a>
    
  </li>
</ul>
            
          </div>
          <div class="col-md-4 search">
            
              <script>
function storeThisPage(){
    sessionStorage["pageBeforeSearch"] = window.location;
    return true;
}
function doneWithSearch(){
    var storedPage = sessionStorage["pageBeforeSearch"];
    if(storedPage){
        window.location = storedPage;
    } else {
        window.location = "index.html"; //fallback
    }
    return false;
}
</script>
<div  style="margin-top:-4px">
<ul style="display:inline; white-space:nowrap"><li>
<form class="navbar-form" action="../search.html" method="get" onsubmit="storeThisPage()">
 <div class="form-group">
  <input type="search" results="5" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form></li>
</ul>
</div>
            
          </div>
        </div>
      </div>
    </div>
    <script>
        //Remove dev portal header and footer when viewing from file system
       if(window.location.protocol == 'file:'){
            var navNode = document.querySelector(".developer-links");
            navNode.parentNode.removeChild(navNode);
        }

    </script>


<div id="wrap" data-spy="scroll" data-target="#sidebar">
  <div class="container">
    <div class="row">
      <div class="col-md-9 pull-right">
        <!-- 
 
<span id="breadcrumbs">
  <a href="../index.html">Home</a>&raquo;
    <a href="Leap_Guides2.html" accesskey="U">Using the Tracking API</a>&raquo;
  Camera Images
</span> -->
        
  <div class="section" id="camera-images">
<h1>Camera Images<a class="headerlink" href="#camera-images" title="Permalink to this headline">Â¶</a></h1>
<p>The Leap Motion controller uses infrared stereo cameras as tracking sensors. You can access the images from these cameras using the <a href="#id343"><span class="problematic" id="id344">|Controller.images|_</span></a> or <a href="#id345"><span class="problematic" id="id346">|Frame.images|_</span></a> functions. These functions provide an <a class="reference external" href="../api/Leap.ImageList.html"><tt class="docutils literal"><span class="pre">ImageList</span></tt></a> object, containing the <a class="reference external" href="../api/Leap.Image.html"><tt class="docutils literal"><span class="pre">Image</span></tt></a> objects. <a href="#id283"><span class="problematic" id="id284">|Controller.images|</span></a> provides the most recent set of images. <a href="#id285"><span class="problematic" id="id286">|Frame.images|</span></a> provides the set of images analysed to create that frame and can be slightly older than the images returned by the <tt class="docutils literal"><span class="pre">Controller</span></tt> directly.</p>
<div class="figure align-center">
<img alt="devguide/../../../images/Leap_Image_Raw.png" src="devguide/../../../images/Leap_Image_Raw.png" />
<p class="caption">An image from one of the cameras. A grid highlighting the significant, complex distortion is superimposed on the image.</p>
</div>
<p>The images can be used for:</p>
<ul class="simple">
<li>Head-mounted display video pass-through</li>
<li>Augmented reality</li>
<li>Computer vision</li>
</ul>
<p>The Image API provides a buffer containing the sensor brightness values and a buffer containing the camera calibration map, which can be used to correct lens distortion and other optical imperfections in the image data.</p>
<div class="section" id="image-api-basics">
<h2>Image API Basics<a class="headerlink" href="#image-api-basics" title="Permalink to this headline">Â¶</a></h2>
<p>Get <a class="reference external" href="../api/Leap.ImageList.html"><tt class="docutils literal"><span class="pre">ImageList</span></tt></a> objects from either <a href="#id347"><span class="problematic" id="id348">|Controller.images|_</span></a> or <a href="#id349"><span class="problematic" id="id350">|Frame.images|_</span></a>. The <a href="#id291"><span class="problematic" id="id292">|Controller.images|</span></a> function gives you the most recent images. <a href="#id293"><span class="problematic" id="id294">|Frame.images|</span></a> gives you the images associated with that frame. Since processing the frame takes a bit of time, the images from the frame will be at least one camera frame behind the images obtained from the controller. (In a future version, the data frame rate may be decoupled from the camera frame rate, so the difference could be larger.) Images from the controller have the smallest latency, but won&#8217;t match up as well to the tracking data of the current frame. When using <a href="#id295"><span class="problematic" id="id296">|Controller.images|</span></a>, you can implement the <a href="#id351"><span class="problematic" id="id352">|Listener_onImages|_</span></a> callback in a <a class="reference external" href="../api/Leap.Listener.html"><tt class="docutils literal"><span class="pre">Listener</span></tt></a> object. Your <a href="#id353"><span class="problematic" id="id354">|Listener.onImages|_</span></a> callback is invoked by the <tt class="docutils literal"><span class="pre">Controller</span></tt> as soon as a new set of images is ready.</p>
<p>Image data is provided as an array of pixel values. The format of this data is reported by the <a class="reference external" href="../api/Leap.Image.html#Leap.Image.format">Image.format</a> value. Currently, one format is in use. This &#8220;INFRARED&#8221; format uses one byte per pixel, defining the brightness measured for that sensor location. You can display infrared-format data as a greyscale image. Future Leap Motion hardware may provide sensor image data in a different format.</p>
<div class="section" id="image-distortion">
<h3>Image Distortion<a class="headerlink" href="#image-distortion" title="Permalink to this headline">Â¶</a></h3>
<p>When a ray of light enters one of the Leap Motion cameras, the lens bends the light ray so that it hits the sensor, which records it as a greyscale brightness value at a specific pixel location. Of course, no lens is perfect, so a ray of light does not land on the sensor in the optically perfect spot. The calibration map provides data to correct this imperfection, allowing you to calculate the true angle of the original ray of light. You can use the corrected angle to generate a distortion-free image, and, using the angles from both images in the stereo pair, you can triangulate the 3D location of a feature identified in both images. Note that the calibration map corrects lens distortion; it does not correct perspective distortion.</p>
<p>For image correction, the distortion data can be fed to a shader program that can efficiently interpolate the correction applied to rays of light. For getting the true angle for a small set of points, you can use the <a href="#id355"><span class="problematic" id="id356">|Image.warp|_</span></a> function (but this is not efficient enough to transform a full bitmap at a high frame rate).</p>
<p>The distortion data is based on the angle of view of the Leap Motion cameras. The image class provides functions, <a class="reference external" href="../api/Leap.Image.html#Leap.Image.ray_scale_x">Image.ray_scale_x</a> and <a class="reference external" href="../api/Leap.Image.html#Leap.Image.ray_scale_y">Image.ray_scale_y</a> that are proportional to view angles large enough to ensure that distortion map covers the entire view, about 150 degrees for the current Leap Motion peripheral. A 150 degree angle of view means that a light ray passing through the lens has a maximum slope of 4/1.</p>
<div class="figure align-center">
<img alt="devguide/../../../images/Leap_Image_Rays.png" src="devguide/../../../images/Leap_Image_Rays.png" />
<p class="caption">A view angle of 150 degrees corresponds to a slope of Â±4 (the tangent of 75 degrees is approximately 4)</p>
</div>
<p>The image above shows a reconstruction of the distortion-corrected image data. The brightness value of each pixel in the image originated from a ray of light entering the camera from a specific direction. The image is reconstructed by calculating the horizontal and vertical slopes represented by each pixel and finding the true brightness value from the image data using the calibration map. The red portions of the image represent areas within the rendering for which no brightness value is available (the actual field of view is less than 150 degrees).</p>
</div>
<div class="section" id="image-orientation">
<h3>Image Orientation<a class="headerlink" href="#image-orientation" title="Permalink to this headline">Â¶</a></h3>
<p>The top of the image is always toward the negative direction of the z-axis of the Leap Motion coordinate system. By default, the Leap Motion software automatically adjusts the coordinate system so that hands enter from the positive direction of the z-axis. (Users can disable auto-orientation using the Leap Motion control panel.) Before hands are inserted into the field of view, it isn&#8217;t possible to know which way the images are oriented, since the user can typically place or mount the device in either physical orientation (i.e. with the green LED on the long side of the device facing one way or the other). If the user places the device in the opposite way than you expect, the images will be upside down until they put their hands into view (or turn the device itself around).</p>
</div>
</div>
<div class="section" id="get-the-raw-images">
<h2>Get the Raw Images<a class="headerlink" href="#get-the-raw-images" title="Permalink to this headline">Â¶</a></h2>
<p>Before you can get image data, you must set the POLICY_IMAGES flag using the <a class="reference external" href="../api/Leap.Controller.html#Leap.Controller.set_policy">Controller.set_policy()</a> function. For privacy reasons, each user must also enable the feature in the Leap Motion control panel for any application to get the raw camera images.</p>
<p>To get the image data, use either the <a href="#id357"><span class="problematic" id="id358">|Controller.images|_</span></a> or the <a href="#id359"><span class="problematic" id="id360">|Frame.images|_</span></a> function. Since the Leap Motion peripheral has two cameras, these functions return an <tt class="docutils literal"><span class="pre">ImageList</span></tt> object that contains two images (this could change in the future if multiple Leap Motion devices can be active at the same time). The image at index 0 is the left camera; the image at index 1 is the right camera. Note that the left-right orientation of the peripheral can be detected automatically based on the direction from which the user inserts his or her hand into the field of view. Detection is enabled by the auto-orientation setting in the Leap Motion control panel.</p>
<p>Once you have an <a class="reference external" href="../api/Leap.Image.html"><tt class="docutils literal"><span class="pre">Image</span></tt></a> object, you can get the 8-bit brightness values from the <a class="reference external" href="../api/Leap.Image.html#Leap.Image.data">data</a> buffer. The length of this buffer is <a class="reference external" href="../api/Leap.Image.html#Leap.Image.width">Image.width</a> times <a class="reference external" href="../api/Leap.Image.html#Leap.Image.height">Image.height</a> times <a class="reference external" href="../api/Leap.Image.html#Leap.Image.bytes_per_pixel">Image.bytes_per_pixel</a>. The width and height of the image changes with the current operating mode of the controller, which can change from frame to frame. Note that in &#8220;robust mode,&#8221; the images are half as tall.</p>
</div>
<div class="section" id="get-the-calibration-map">
<h2>Get the Calibration Map<a class="headerlink" href="#get-the-calibration-map" title="Permalink to this headline">Â¶</a></h2>
<p>The calibration map can be used to correct image distortion due to lens curvature and other imperfections. The map is a 64x64 grid of points. Each point consists of two 32-bit values, so the buffer size is 128 times 64 times 4. You can get the calibration map buffer using the <a class="reference external" href="../api/Leap.Image.html#Leap.Image.distortion">Image.distortion</a> function.</p>
<p>Each point in the buffer indicates where to find the corrected brightness value for the corresponding pixel in the raw image. Valid coordinates are normalized in the range [0..1]. Individual elements of the calibration map can have a value in the range [-0.6..2.3], but coordinates below zero or above 1 are invalid. Discard values outside the range [0..1] when using the calibration data.</p>
<p>To convert to pixel coordinates multiply by the width or height of the image. For pixels that lie in between the calibration grid points, you can interpolate between the nearest grid points. The camera lenses have a very large angle of view (roughly 150 degrees) and have a large amount of distortion. Because of this, not every point in the calibration grid maps to a valid pixel. The following rendering shows the lens correction data as color values. The left image shows the x values; the right side shows the y values.</p>
<div class="figure align-center">
<img alt="devguide/../../../images/Leap_Distortion.png" src="devguide/../../../images/Leap_Distortion.png" />
<p class="caption">The red values indicate map values that fall outside the image.</p>
</div>
<p>The size of the calibration map is subject to change in the future, so the <tt class="docutils literal"><span class="pre">Image</span></tt> class provides the grid dimensions with the <a class="reference external" href="../api/Leap.Image.html#Leap.Image.distortion_width">distortion_width</a> (actually twice the width to account for two values per grid point) and <a class="reference external" href="../api/Leap.Image.html#Leap.Image.distortion_height">distortion_height</a> functions. The length of the buffer containing the calibration data is <a class="reference external" href="../api/Leap.Image.html#Leap.Image.distortion_width">distortion_width</a> times <a class="reference external" href="../api/Leap.Image.html#Leap.Image.distortion_height">distortion_height</a> times 4 bytes.</p>
</div>
<div class="section" id="image-ray-correction">
<h2>Image Ray Correction<a class="headerlink" href="#image-ray-correction" title="Permalink to this headline">Â¶</a></h2>
<p>You can correct the raw image distortion in two ways:</p>
<ul class="simple">
<li>Use the <a href="#id363"><span class="problematic" id="id364">|Image.warp|_</span></a> and <a href="#id365"><span class="problematic" id="id366">|Image.rectify|_</span></a> functions.</li>
<li>Use the data in the <a class="reference external" href="../api/Leap.Image.html#Leap.Image.distortion">Image.distortion</a> buffer directly.</li>
</ul>
<p>The <a href="#id367"><span class="problematic" id="id368">|Image_warp|_</span></a> and <a href="#id369"><span class="problematic" id="id370">|Image_rectify|_</span></a> functions are the simpler method, but processing each pixel individually on the CPU is relatively slow. Use these functions if you are only correcting a few points, you don&#8217;t need to process data in real time, or when you cannot use GPU shaders. The distortion buffer is designed to be used with a GPU shader program and can correct the entire raw image while maintaining a good application frame rate.</p>
<div class="section" id="correction-using-image-warp">
<h3>Correction using <a href="#id317"><span class="problematic" id="id318">|Image.warp|</span></a><a class="headerlink" href="#correction-using-image-warp" title="Permalink to this headline">Â¶</a></h3>
<p><a href="#id371"><span class="problematic" id="id372">|Image.warp|_</span></a> takes a ray direction and returns the pixel coordinates into the raw image data that specify the brightness value recorded for that ray direction.</p>
</div>
<div class="section" id="correction-using-shaders">
<span id="image-shaders"></span><h3>Correction using Shaders<a class="headerlink" href="#correction-using-shaders" title="Permalink to this headline">Â¶</a></h3>
<p>A more efficient way to correct the entire image is to use a GPU shader program. Pass the image data to a fragment shader as a normal texture and the distortion data as encoded textures. You can then texture a quad by decoding the distortion data and using that to look up the correct brightness value in the image texture.</p>
<p>TODO: example code</p>
</div>
<div class="section" id="encoding-distortion-data-in-an-32-bit-argb-texture">
<h3>Encoding Distortion Data in an 32-bit ARGB Texture<a class="headerlink" href="#encoding-distortion-data-in-an-32-bit-argb-texture" title="Permalink to this headline">Â¶</a></h3>
<p>If a 32-bit-per-component texture format is not available on your target platform, you can use a separate texture for the x and y lookup values and encode the floating point values into multiple 8-bit color components. You then have to decode the values before using them to look up the raw brightness values.</p>
<p>A common method for encoding floating point data in a texture is to decompose the input value into four lower-precision values and then restore them in the shader. For example, you can encode a floating point number into a Color object that has four 8-bit components as follows:</p>
<div class="code cpp highlight-python"><div class="highlight"><pre>Color encodeFloatRGBA(float input)
{
    input = (input + 0.6)/2.3; //scale the input value to the range [0..1]
    float r = input;
    float g = input * 255;
    float b = input * 255 * 255;
    float a = input * 255 * 255 * 255;

    r = r - (float)Math.floor(r);
    g = g - (float)Math.floor(g);
    b = b - (float)Math.floor(b);
    a = a - (float)Math.floor(a);

    return Color(r, g, b, a);
}
</pre></div>
</div>
<p>To recompose the value in the fragment shader, you look up the value in the texture and perform the reciprocal operation. To avoid losing too much precision, encode the x and y distortion values in separate textures. Once the distortion indices are sampled from the textures and decoded, you can look up the correct brightness value from the camera image texture.</p>
<div class="code c highlight-python"><div class="highlight"><pre>uniform sampler2D texture;
uniform sampler2D vDistortion;
uniform sampler2D hDistortion;

varying vec2 distortionLookup;
varying vec4 vertColor;
varying vec4 vertTexCoord;

const vec4 decoderCoefficients = vec4(1.0, 1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0));

void main() {
  vec4 vEncoded = texture2D(vDistortion, vertTexCoord.st);
  vec4 hEncoded = texture2D(hDistortion, vertTexCoord.st);
  float vIndex = dot(vEncoded, decoderCoefficients) * 2.3 - 0.6;
  float hIndex = dot(hEncoded, decoderCoefficients) * 2.3 - 0.6;

  if(vIndex &gt;= 0.0 &amp;&amp; vIndex &lt;= 1.0
        &amp;&amp; hIndex &gt;= 0.0 &amp;&amp; hIndex &lt;= 1.0)
  {
      gl_FragColor = texture2D(texture, vec2(hIndex, vIndex)) * vertColor;
  } else {
      gl_FragColor = vec4(1.0, 0, 0, 1.0); //show invalid pixels as red
  }
}
</pre></div>
</div>
</div>
<div class="section" id="correction-using-bilinear-interpolation">
<h3>Correction using bilinear interpolation<a class="headerlink" href="#correction-using-bilinear-interpolation" title="Permalink to this headline">Â¶</a></h3>
<p>In situations where shaders are not feasible you may be able to correct image distortion faster using well-optimized bilinear interpolation than when using the <a href="#id373"><span class="problematic" id="id374">|Image_warp|_</span></a> function. (As with any such optimization, you should verify your results with performance testing.)</p>
<p>Recall that the distortion map contains a 64x64 element grid. Imagine these grid elements evenly spread out over your target image (with element [0, 0] in the lower-lefthand corner and [64,64] in the upper-right). Each element contains a horizontal coordinate and a vertical coordinate identifying where in the sensor image data to find the recorded brightness for that pixel in the target image. To find the brightness values for pixels in between the distortion grid elements, you have to interpolate between the four nearest grid points.</p>
<div class="figure align-center">
<img alt="devguide/../../../images/Interpolation.png" src="devguide/../../../images/Interpolation.png" />
</div>
<p>The base algorithm for finding the distortion-corrected brightness for a given pixel in the target image is:</p>
<ol class="arabic simple">
<li>Find the four points in the calibration grid surrounding the target pixel.</li>
<li>Calculate the interpolation weights based on the distance of the target to each surrounding grid point.</li>
<li>Lookup the horizontal and vertical values at each of the four grid elements.</li>
<li>Bilinearly interpolate the horizontal value using the distance-based weighting factors.</li>
<li>Repeat this interpolation for the vertical value.</li>
<li>Reject any points where either the horizontal or vertical value is outside of the range [0..1]. There is no recorded data for such points.</li>
<li>Denormalize the values so that they represent pixel coordinates into the raw sensor data.</li>
<li>Look up the sensor value at the computed pixel coordinates.</li>
<li>Set this brightness value at the original coordinates in the target image.</li>
</ol>
<p>Performing bilinear interpolation by looping over every image pixel is still too slow in Python. Instead, you can use functions provided by the OpenCV library to perform the interpolation. First, convert the distortion data into a format that can be used by the <a class="reference external" href="http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#remap">cv2.remap()</a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">cv2</span><span class="o">,</span> <span class="nn">Leap</span><span class="o">,</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">convert_distortion_maps</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>

    <span class="n">distortion_length</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">distortion_width</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">distortion_height</span>
    <span class="n">xmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">distortion_length</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">ymap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">distortion_length</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">distortion_length</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">xmap</span><span class="p">[</span><span class="n">distortion_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">distortion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span>
        <span class="n">ymap</span><span class="p">[</span><span class="n">distortion_length</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">distortion</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span>

    <span class="n">xmap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xmap</span><span class="p">,</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">distortion_height</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">distortion_width</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">ymap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ymap</span><span class="p">,</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">distortion_height</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">distortion_width</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

    <span class="c">#resize the distortion map to equal desired destination image size</span>
    <span class="n">resized_xmap</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">xmap</span><span class="p">,</span>
                              <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">),</span>
                              <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                              <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span>
    <span class="n">resized_ymap</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">ymap</span><span class="p">,</span>
                              <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">),</span>
                              <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                              <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span>

    <span class="c">#Use faster fixed point maps</span>
    <span class="n">coordinate_map</span><span class="p">,</span> <span class="n">interpolation_coefficients</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">convertMaps</span><span class="p">(</span><span class="n">resized_xmap</span><span class="p">,</span>
                                                                 <span class="n">resized_ymap</span><span class="p">,</span>
                                                                 <span class="n">cv2</span><span class="o">.</span><span class="n">CV_32FC1</span><span class="p">,</span>
                                                                 <span class="n">nninterpolation</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">coordinate_map</span><span class="p">,</span> <span class="n">interpolation_coefficients</span>
</pre></div>
</div>
<p>And then pass the maps and the corresponding image to the <tt class="docutils literal"><span class="pre">cv2.remap()</span></tt> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">undistort</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">coordinate_map</span><span class="p">,</span> <span class="n">coefficient_map</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
    <span class="n">destination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ubyte</span><span class="p">)</span>

    <span class="c">#wrap image data in numpy array</span>
    <span class="n">i_address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">data_pointer</span><span class="p">)</span>
    <span class="n">ctype_array_def</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ubyte</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span>
    <span class="c"># as ctypes array</span>
    <span class="n">as_ctype_array</span> <span class="o">=</span> <span class="n">ctype_array_def</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="n">i_address</span><span class="p">)</span>
    <span class="c"># as numpy array</span>
    <span class="n">as_numpy_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">as_ctype_array</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">as_numpy_array</span><span class="p">,</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>

    <span class="c">#remap image to destination</span>
    <span class="n">destination</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">img</span><span class="p">,</span>
                            <span class="n">coordinate_map</span><span class="p">,</span>
                            <span class="n">coefficient_map</span><span class="p">,</span>
                            <span class="n">interpolation</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span>

    <span class="c">#resize output to desired destination size</span>
    <span class="n">destination</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span>
                             <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span>
                             <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                             <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">destination</span>
</pre></div>
</div>
<p>Note that you should avoid converting the distortion maps every frame. They only change when a different device is plugged in, the image reverses orientation (when hands enter from the opposite side), or the device is recalibrated. The following code only converts the distortion maps once (but doesn&#8217;t handle the cases where the distortion maps can change):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">controller</span><span class="p">):</span>
    <span class="n">maps_initialized</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">while</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">frame</span><span class="p">()</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">maps_initialized</span><span class="p">:</span>
                <span class="n">left_coordinates</span><span class="p">,</span> <span class="n">left_coefficients</span> <span class="o">=</span> <span class="n">convert_distortion_maps</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">right_coordinates</span><span class="p">,</span> <span class="n">right_coefficients</span> <span class="o">=</span> <span class="n">convert_distortion_maps</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">maps_initialized</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="n">undistorted_left</span> <span class="o">=</span> <span class="n">undistort</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">left_coordinates</span><span class="p">,</span> <span class="n">left_coefficients</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
            <span class="n">undistorted_right</span> <span class="o">=</span> <span class="n">undistort</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">right_coordinates</span><span class="p">,</span> <span class="n">right_coefficients</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>

            <span class="c">#display images</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">&#39;Left Camera&#39;</span><span class="p">,</span> <span class="n">undistorted_left</span><span class="p">)</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s">&#39;Right Camera&#39;</span><span class="p">,</span> <span class="n">undistorted_right</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span> <span class="o">==</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&#39;q&#39;</span><span class="p">):</span>
                <span class="k">break</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">controller</span> <span class="o">=</span> <span class="n">Leap</span><span class="o">.</span><span class="n">Controller</span><span class="p">()</span>
    <span class="n">controller</span><span class="o">.</span><span class="n">set_policy_flags</span><span class="p">(</span><span class="n">Leap</span><span class="o">.</span><span class="n">Controller</span><span class="o">.</span><span class="n">POLICY_IMAGES</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">run</span><span class="p">(</span><span class="n">controller</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="draw-tracking-data-over-image">
<h2>Draw Tracking Data over Image<a class="headerlink" href="#draw-tracking-data-over-image" title="Permalink to this headline">Â¶</a></h2>
<p>It is reasonably straightforward to draw representations of the Leap Motion tracking data over the camera image. If you have drawn the raw image data to a bitmap, you can find the pixel corresponding to a Leap Motion position using the <a href="#id375"><span class="problematic" id="id376">|Image_warp|_</span></a> function.</p>
<p>Converting a position in Leap Motion coordinates to horizontal and vertical slopes (from the camera perspective) requires knowing how far the cameras are from the origin of the Leap Motion coordinate system. For the current peripheral version, the offset on the x axis is 20mm to either side. The cameras are on the x-axis, so there is no z offset. The slope is simply the distance from the camera in the image plane &#8211; the x-coordinate for the horizontal slope; the z-coordinate for the vertical slope &#8211; divided by the distance to the image plane, the z-coordinate. The following diagram illustrates the geometry for the horizontal slope:</p>
<div class="figure align-center">
<img alt="devguide/../../../images/Image_Slope.png" src="devguide/../../../images/Image_Slope.png" />
<p class="caption">The calculation is shown for the left camera; add the offset distance instead of subtracting for the right camera.</p>
</div>
<p>Once you know the ray slope values, you can get the pixel coordinates using <a href="#id337"><span class="problematic" id="id338">|Image_warp|</span></a>.</p>
<p>Note: The offset can be different for different form factors of the Leap Motion controller, but there is currently no way to get this value from the API.</p>
<p>If you have rendered the corrected image data, then correlating tracking data to the image data depends on how you rendered the image. For 3D scenes, this is a matter of using a consistent scale and correct placement of the textured quad showing the camera image. For other types of rendering, you must convert the ray slopes representing a Leap Motion position to a target image pixel according to the way that you corrected the image data.</p>
</div>
<div class="section" id="calculate-the-direction-to-an-image-feature">
<h2>Calculate the Direction to an Image Feature<a class="headerlink" href="#calculate-the-direction-to-an-image-feature" title="Permalink to this headline">Â¶</a></h2>
<p>Get the direction to an image feature with the <a href="#id377"><span class="problematic" id="id378">|Image.rectify|_</span></a> function. <a href="#id341"><span class="problematic" id="id342">|Image.rectify|</span></a> returns a vector containing the horizontal and vertical slopes (as defined from the camera point of view) given the pixel coordinates in the raw image data.</p>
<p>If you can identify the same feature in both images with sufficient accuracy, you can triangulate the 3D position using the set of slope values from the two cameras.</p>
</div>
<div class="section" id="head-mounted-display-mode">
<h2>Head-Mounted Display Mode<a class="headerlink" href="#head-mounted-display-mode" title="Permalink to this headline">Â¶</a></h2>
<p>The Leap Motion service/daemon software provides a mode that optimizes tracking when the Leap Motion hardware is attached to a head-mounted display. In this mode, the Leap Motion software expects to view hands from the top rather than the bottom. When ambiguity exists whether the palm of a hand is facing toward or away from the Leap Motion sensors, setting this mode makes it more likely that the software will initialize the hand model so that it is facing away from the sensors. Thus this mode is good for mounting the Leap Motion device on the face of a head-mounted display rig.</p>
<p>To turn on the mode in your application, enable the optimize HMD policy:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">controller</span><span class="o">.</span><span class="n">set_policy</span><span class="p">(</span><span class="n">Leap</span><span class="o">.</span><span class="n">Controller</span><span class="o">.</span><span class="n">POLICY_OPTIMIZE_HMD</span><span class="p">);</span>
</pre></div>
</div>
<p>The policy is always denied for hardware that cannot be mounted on an HMD, such as those embedded in laptops or keyboards.</p>
</div>
</div>


           <!-- get_disqus_sso -->
      </div>
      <div id="sidebar" class="col-md-3">
        <div class="well-sidebar" data-offset-top="188">
          <ul>
            <li><a href="../index.html" title="Home">Python Docs (v3.1)</a></li>
          </ul><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Leap_Overview.html">API Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practices/Leap_Practices.html">Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="Leap_Guides.html">Application Development</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Leap_Guides2.html">Using the Tracking API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Leap_Controllers.html">Connecting to the Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Tracking.html">Tracking Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Frames.html">Frames</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Hand.html">Hands</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Pointables.html">Fingers</a></li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Coordinate_Mapping.html">Coordinate Systems</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Camera Images</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#image-api-basics">Image API Basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#image-distortion">Image Distortion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#image-orientation">Image Orientation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#get-the-raw-images">Get the Raw Images</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get-the-calibration-map">Get the Calibration Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="#image-ray-correction">Image Ray Correction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#correction-using-image-warp">Correction using |Image.warp|</a></li>
<li class="toctree-l4"><a class="reference internal" href="#correction-using-shaders">Correction using Shaders</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encoding-distortion-data-in-an-32-bit-argb-texture">Encoding Distortion Data in an 32-bit ARGB Texture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#correction-using-bilinear-interpolation">Correction using bilinear interpolation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#draw-tracking-data-over-image">Draw Tracking Data over Image</a></li>
<li class="toctree-l3"><a class="reference internal" href="#calculate-the-direction-to-an-image-feature">Calculate the Direction to an Image Feature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#head-mounted-display-mode">Head-Mounted Display Mode</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Leap_Serialization.html">Serializing Tracking Data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/Leap_Classes.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../supplements/Leap_Supplements.html">Appendices</a></li>
</ul>


        </div>
      </div>
        
    </div>
  </div>
</div>
<!--

<div class="ribbon">
    <p>Python</p>
</div>


<footer>
  <div id="footer" class="container">
    <div class="container">
      <div class="copyright">
        <span>Copyright &copy; 2012 - 2016, Leap Motion, Inc.</span>
      </div>
    </div>
  </div>
</footer>
  </body>
</html>